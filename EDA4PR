ç ”ç©¶èƒŒæ™¯
å…¸å‹çš„èŠ¯ç‰‡è®¾è®¡æµç¨‹æ˜¯å…ˆåšå‰ç«¯ã€åç«¯è®¾è®¡ï¼Œå†å»éªŒè¯æ€§èƒ½ã€åŠŸè€—å’Œé¢ç§¯ã€‚ä½†ç”±äºæµç¨‹å¤ªé•¿ï¼Œåœ¨å‰ç«¯è®¾è®¡çš„æ—¶å€™ï¼Œæ— æ³•ä¿è¯åç«¯è®¾è®¡çš„æ•ˆæœï¼Œæ‰€ä»¥å¾ˆå¤šæ—¶å€™éœ€è¦è¿›è¡Œè·¨ç¯èŠ‚å»ºæ¨¡ï¼Œåœ¨æ—©æœŸè®¾è®¡ç¯èŠ‚é¢„æµ‹åç»­ç¯èŠ‚çš„æ±‚è§£è´¨é‡ï¼Œè¿™å½“ä¸­å°±å¾ˆé€‚åˆAIç®—æ³•æ¥è¿›è¡Œè¾…åŠ©ã€‚

é™¤äº†å»ºæ¨¡ä¹‹å¤–ï¼Œå¦å¤–ä¸€ä¸ªå…³é”®é—®é¢˜æ˜¯ä¼˜åŒ–ã€‚EDAä¸­ç»å¸¸è¦æ±‚è§£å„ç§å„æ ·çš„ç»„åˆä¼˜åŒ–é—®é¢˜ã€‚è¿™äº›é—®é¢˜å¾€å¾€æ˜¯ NPéš¾é¢˜ï¼Œæ¯”å¦‚ç»å…¸çš„æ—…è¡Œå•†é—®é¢˜ã€‚ä¼ ç»Ÿä¸Šï¼Œæˆ‘ä»¬ä¼šé€šè¿‡ä¸€äº›å¯å‘æ¢ç´¢çš„æ–¹æ³•æ¥æ±‚è§£ã€‚ä½†éšç€è§„æ¨¡ä¸æ–­å¢å¤§ã€è®¾è®¡çº¦æŸè¶Šæ¥è¶Šå¤šï¼Œè¿™ç§æ¢ç´¢å¾€å¾€é‡åˆ°æ•ˆç‡ç“¶é¢ˆï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦é€šè¿‡æœºå™¨å­¦ä¹ æŠ€æœ¯è¿›è¡Œè¾…åŠ©ï¼Œå¯»æ‰¾æœ‰æ•ˆç­–ç•¥ï¼Œæé«˜æ•ˆç‡ã€‚

image-20250105141458960

éš¾ç‚¹
image-20241013184936794

å¤§å›¾-->

æ•°æ®é›†-->

æ³›åŒ–èƒ½åŠ›-->

éDAG?

route: 3Dï¼Œ45Â°ï¼Œ30Â°

å…ˆè¿›çš„å·¥è‰ºï¼š7nm

å¾ˆå¤šPlacer and Routerè¿˜æ˜¯æœ‰å¾ˆå¤šäººå·¥å®šä¹‰çš„è¶…å‚æ•°ï¼Ÿï¼ˆä¸generalï¼‰

ç°åœ¨çœŸçš„è¿˜æœ‰å¿…è¦æŠŠRouteråˆ†æˆGlobal å’ŒDetail å—ï¼Ÿ

GR: total maze routing

GR: Consider timing and power consumption

ç ”ç©¶æ–¹å‘
Cross-Stage Prediction  
routing congestion prediction
background
Routing congestion can overwhelm routing resources and lead to low cell utilization and routing detours  

congestion is not known accurately until late in the design cycle, after placement and routing.  

Many modern placement and synthesis tools leverage congestion estimation in their cost analysis in order to minimize the effects of congestion in the final physical design 

image-20241101193119582

It is known that the total net length can be a good proxy for congestion   

A simple approximation for congestion prediction is to use the size of the local neighborhood  

image-20241102170308031

å’Œfan-in, fan-outå¼ºç›¸å…³

Precise congestion prediction from a placement solution plays a crucial role in circuit placement   

Multiple previous works have attempted to predict detailed routing congestion in the placement step in an effort to optimize routability of the placement solution: RUDY, POLAR 2.0. All these techniques are implemented  in the placement step and need the position information of cells .

To avoid the high computation cost of placement, it is more useful to be able to predict congestion in the logic synthesis phase.   

congestion prediction problem can be frame as node regression problem  

with the growth of circuit scale and complexity, time consumption
tends to be unacceptable when utilizing a global router in the placement cycle to obtain the congestion map.  

Current machine learning models commonly follow a two-phase workflow. First, based on domain knowledge, human experts generate various local features on the circuit using predefined functions on netlist. Then, based on the generated features, a specific model, e.g. convolution neural network (CNN) model is designed to predict either the routing demand map or the congestion map  

the emergence of Graph Neural Network (GNN) triggered applications of undirected homogeneous graphs models on routing congestion prediction, since a VLSI circuit can be naturally represented by a graph  

RouteNet-DRC Hotspot Prediction-ICCAD-2018-CNN
background:

Every chip design project must complete routing without design rule violation before tapeout. However, this basic requirement is often difficult to be satisfied especially when routability is not adequately considered in early design stages.  

In light of this fact, routability prediction has received serious attention in both academic research and industrial tool development. Moreover, routability is widely recognized as a main objective for cell placement  

CNN and Transfer Learning  

CNN learns more abstract patterns from images  

Our RouteNet transfers such state-of-the-art ability in image pattern recognition to circuits for capturing the patterns about routability. RouteNet predicts routability based on a pretrained ResNet architecture  

Fully Convolutional Network (FCN): outputs an image with size equal to or smaller than input.   many FCNs have both deep and shallow paths in one network.   

RUDY(Rectangular Uniform wire DensitY)

å®ƒè¢«ç”¨ä½œæˆ‘ä»¬RouteNetçš„è¾“å…¥ç‰¹å¾ï¼Œå› ä¸ºå®ƒä¸è·¯ç”±æ‹¥å¡éƒ¨åˆ†ç›¸å…³ï¼Œè·å–é€Ÿåº¦å¿«ï¼Œå¯ä»¥ç›´æ¥è¡¨ç¤ºä¸ºä¸RouteNetç›¸å»åˆçš„å›¾åƒ

challenge of macros

image-20250205214716706

The orange circles in Figure 3 indicate a strong tendency for hotspots to aggregate at the small gap between neighboring macros  

Blue dashed circles indicate the remaining sparsely distributed hotspots 

image-20250205220737891

æœ‰macroï¼Œçº¿æ€§ç¨‹åº¦ä½

task:

predict overall routability (DRC count), åˆ†ç±»ä»»åŠ¡ï¼Œé¢„æµ‹æ€»çš„#DRV

predict DRC hotspot locations.DRC hotspots mean the specific locations with high density of DRVs. like an end-to-end object detection task, which is more difficult to solve. GCellå†…#DRVè¶…è¿‡è®¾å®šå€¼åˆ™ä¸ºDRC hotspot

contribution:

image-20250205210214325

mixed-size macros

first systematic study on CNN-based routability prediction  

high accuracy and high speed  

flow:

image-20250205222502598

model

#DRV prediction

ResNet18-based

image-20250205223554347

preprocess

image-20250205223153166

image-20250205223742770

ResNetæ˜¯ä¸€ä¸ªå›ºå®šè¾“å…¥ï¼ˆ224*224ï¼‰çš„æ¨¡å‹ï¼Œä¸ºäº†ä½¿ç”¨çŸ¥è¯†è¿ç§»ï¼Œå°†è¾“å…¥image-20250205223849469é€šè¿‡æ’å€¼çš„æ–¹æ³•å˜æˆimage-20250205223907748ã€‚å…·ä½“æ€ä¹ˆæ’ï¼Ÿ

hotspot prediction

image-20250205224325007

data:

dataset:

ISPD 2015 benchmarks  

image-20250205225007139

different placement made by â€œobstacle-aware macro placement" algorithm [5].  

each floorplan is placed and routed by Cadence Encounter v14.20 [2]  

experiment:

image-20250205230614878

image-20250205230628088

image-20250205230725019

we compare the TPR of all methods under the same FPR (error under 1%)

image-20250205230816030

CongestionNet-predict congestion hotspots-IFIP-2019-GNN(GAT)-nvidia
a graph-based deep learning method for predicting routing congestion hotspots from a netlist before placement.  Predict the detail routed lower metal layer congestion values  

image-20241101192745004

why low layer? å› ä¸ºè¾ƒä½é‡‘å±å±‚ä¸Šçš„æ‹¥å¡ä¸»è¦æ˜¯ç”±å±€éƒ¨é€»è¾‘ç»“æ„é©±åŠ¨çš„ï¼Œè€Œä¸æ˜¯ç”±æ— å…³é€»è¾‘ç°‡ä¹‹é—´çš„è¾ƒé•¿äº’è¿é©±åŠ¨çš„ï¼Œåè€…å¾€å¾€åœ¨è¾ƒé«˜é‡‘å±å±‚ä¸Šè¿è¡Œ. predicting lower metal layer congestion is not only more important for the underlying task of identifying congested logic structures, but also simplifies the task for our
graph based network  

contribution:

é˜¶æ®µæ—©,åªä½¿ç”¨ç½‘è¡¨

ç”±äºè¯¥æ¨¡å‹ä»…åŸºäºç½‘è¡¨çš„é€»è¾‘ç»“æ„è€Œä¸æ˜¯ä»»ä½•ç‰¹å®šçš„å•å…ƒå¸ƒå±€è¿›è¡Œé¢„æµ‹ï¼Œå› æ­¤å®ƒæ¶ˆé™¤äº†åŸºäºå¸ƒå±€çš„æ–¹æ³•ä¸­å­˜åœ¨çš„æ¬¡ä¼˜å¸ƒå±€çš„ä¼ªå½±image-20241101192504194

can be done without any physical information  

GNN, å¿«

the first work exploring the use of graph based deep learning for physical design problems  

æ•°æ®:

image-20241101194746768

image-20241101195219055

roughly 5000 distinct cell types  

we project our per cell predictions back onto their respective 2D grid (using the final ground truth physical placement) and average all cells within each grid cell to come up with a predicted value that can be compared to the original ground truth grid value.  

æ¨¡å‹å‚æ•°:

an 8 layer Graph Attention Network (GAT) with size 16 intermediate (or hidden) state  

æ— å‘å›¾, each node corresponds to a cell 

èŠ‚ç‚¹ç‰¹å¾: length 50 for each cell type and each cellâ€™s logic description as well as the pin count and cell size of that cell  

å®éªŒ:

report correlation values using the Kendall ranking coefficient  

å®é™…æ•ˆæœå¯è§†åŒ–

image-20241101211844804

image-20241007114109425

å¯¹æ¯”å®éªŒ

image-20241101214611345

æ¶ˆèå®éªŒ

image-20241101214630174

cell type or function is an essential part of our predictions.   

cell type ä¸æ˜¯æ²¡èµ·ä½œç”¨å—

ç¼ºç‚¹: 

model needs to be retrained for every new process technology, since the embeddings are over cell types specific to a process technology.  

it occasionally over predicts congestion in areas of low to moderate congestion, such as in most failing parts of Partition A  

due to the graph based nature of the model, it sometimes makes overly soft decision boundaries  

image-20241102170708557

the CongestionNet uses informative cell attributes (cell size and pin count) alone as the input to the GAT and does not use any embedding encoding the netlist structure  

å¯æ”¹è¿›çš„ç‚¹:

image-20241101215450089

-Congestion prediction + embedding + matrix factorization + partition-arXiv-2021-GNN(Sage)-
background

predicting cell congestion due to improper logic combination can reduce the burden of subsequent physical implementations.  

previous work: require informative cell features  

Although the global routing result provides a good estimation of routing congestion [6], [19], an awareness of high congestion areas at an early design stage is of great importance to provide fast feedback and shorten design cycles

Multiple works have attempted to predict detailed routing congestion in the placement step in an effort to optimize routability of the placement solution  

task

image-20241102170157570

during the logic synthesis stage  

image-20241102185917955

åˆ°åº•æ˜¯ä»€ä¹ˆæ—¶å€™çš„congestionæ•°æ®? Routingåçš„çœŸå®å€¼è¿˜æ˜¯é¢„æµ‹plcamentåçš„congestion RUDYé¢„æµ‹å€¼? åº”è¯¥æ˜¯Global Routingåçš„:å¼ºè°ƒäº†congestion value = wiring demand/routing capacity

image-20241102190757814

contrbution

data

DAC2012 contest benchmark

http://archive.sigda.org/dac2012/contest/dac2012_contest.html

image-20241102185210635

OpenROAD dataset

image-20241102185314200

place via DREAMPLACE  

image-20241102185814366

Macros and terminals are removed from the graph  

Nets with degree more than 10 are excluded from the final graph as they introduce cliques too large to work with efficiently.   

node features (pin number, cell size) , This follows the flow of CongestionNet

image-20241102190725383

flow:

image-20241102193019887

congestion value for each grid cell computed as the wiring demand divided by the routing capacity , The output along the z-axis is reduced by a max function,   

Our focus is on predicting congestion due to local logic structure, which manifests itself on lower metal layers. Therefore, we use congestion labels from the lower half of the metal layers to train and evaluate the model  

æ¨ç†çš„æ—¶å€™å–æ‰€æœ‰cellçš„é¢„æµ‹å¹³å‡å€¼

 

principle

æå‡ºç›¸è¿è¶Šè¿‘çš„èŠ‚ç‚¹ç›¸ä¼¼åº¦è¶Šé«˜,

æå‡ºstructural node similarity  

image-20241102182916257

Sub-graph partition ? METIS? ClusterGCN?

Matrix Factorization  ?

model

The key difference between this approach and CongestionNet lies in embedding pipeline 

graph is undirected complete circuit is too large for direct matrix factorization and must be partitioned into clusters, use METIS partitioning tool   in ClusterGCN

Sub-graph partition: clusters of â‰ˆ 5000 nodes each

Matrix Factorization  ?

experiment

three metrics of correlation to measure performance:   Pearson, Spearman, Kendall 

Before evaluation, both the prediction and the label have some (very low) noise added to them.   

image-20241102204924004

image-20241102204932495

image-20241102204956720

image-20241102205029766

PGNN-DRVs prediction+Pin Proximity Graph-ICCAD-2022-GNN+UNet(CNN)-Korea
background

(1) pin accessibility and (2) routing congestion are two major causes of DRVs (design rule violations)  

Particularly, the complex design rules put so much burden on physical design, demanding lots of iterations on the time-consuming process of cell placement and net routing to clean up all DRVs (design rule violations) before tapping out . Thus, at the placement stage, if we were able to identify, with high confidence, DRC (design rule check) hotspots that would be
likely to occur at the routing stage, we can pay more attention  

shortcoming of image based:

local pin accessibility cannot be accurately modeled by pin pattern image alone  

using high-resolution pin pattern images incur significant additional run-time as well as memory overhead to the prediction models  

to optimize the placement before routing.  

task

a novel ML based DRC hotspot prediction technique,   

GNN is used to embed pin accessibility information, U-net is used to extract routing congestion information from grid-based
features  

image-20241108113804178

image-20241108100942346

placement åˆ†å‰²ä¸ºgrid, é•¿å®½=G-Cell

DRVs are extracted as the ground-truth after detailed routing  

contribution

GNN model, base pin proximity graph

model

PGNN can adopt pin proximity graph as well as grid-based feature map as input feature  

Pin Proximity Graph :

æ— å‘å›¾ï¼Œ åŒæ„å›¾

image-20241108105308585

image-20241108105400483

U-Net:

image-20241108100615500

featrue:

image-20241108111019050

image-20241108111430728

æ•´ä½“æ¨¡å‹:

image-20241108110729825

æ•°æ®é›†:

image-20241108111933323

ä»¥åä¹Ÿå¯ä»¥è¿™ä¹ˆåš, åŒä¸€ä¸ªbenchmarkä¸åŒçš„configå‚æ•°å°±æœ‰ä¸åŒçš„æ•°æ®

experiment

Nangate 15nm library  

9 groups are used for training and the remaining 1 group for test.   KæŠ˜éªŒè¯

image-20241108112502662

positive å’Œ negativeæ˜¯ä»€ä¹ˆæ„æ€?

å¯è§†åŒ–:

image-20241108102857037

æ¶ˆèå®éªŒ:

image-20241108112646099

ä»¥åä¹Ÿå¯ä»¥è¿™æ ·ç”¨ç‰¹å¾æ¶ˆè?

å¯¹æ¯”å®éªŒ(F1-score):

image-20241108112751008

image-20241108114209199

æ³¨æ„ä¸éœ€è¦GR!

GR-Cong is obtained from ICC2 after global routing stage, and grids with high routing congestion are classified as DRC hotspot. å•†ç”¨  

RouteNetå’ŒJ-Netéƒ½æ˜¯ç›¸å…³çš„å­¦æœ¯å·¥ä½œ

æ—¶é—´å¯¹æ¯”:

image-20241108114501484

LHNN-CongestionPrediction-DAC-2022-GNN-CUHK+Huawei+YiboLin
background

å›¾çš„èŠ‚ç‚¹çš„è®¾ç½®å¾ˆæ–°é¢–

with the growth of circuit scale and complexity, time consumption
tends to be unacceptable when utilizing a global router in the placement cycle to obtain the congestion map.  

due to the need for the "shift-left" in circuit design, researchers begin to seek alternative solutions in machine learning [4] [5] to achieve accurate and fast congestion map prediction  

task

two related tasks, routing demand regression and congestion classification  

data

regard each G-cell as a node and add an edge between two nodes if the respective two G-cells are adjacent.  

hypergraphs and heterogeneous  graph , ä¸¤ç§èŠ‚ç‚¹ï¼šG-cellå’ŒG-net

image-20241108141650136

image-20241108142449292

featureï¼š

image-20241108142931213

image-20241108145640376

ISPD 2011 [16] and DAC 2012 [17] contest benchmarks , 

model

image-20241219145252874

image-20241108144617443

ä»–è¿™é‡Œè¯´congestion mapæ˜¯ä¸€ä¸ªäºŒå€¼åŒ–(0/1?)çš„æ•°æ®é›†ï¼Œ æ‰€ä»¥æ˜¯åˆ†ç±»ä»»åŠ¡, ä½†æ˜¯ä¸ºäº†åˆ©ç”¨æ•°æ®ï¼ŒåŒæ—¶é˜²æ­¢routing demandçš„ä¿¡æ¯ä¸¢å¤±ï¼Œ è¿˜è®¾ç½®äº†ä¸€ä¸ªé¢„æµ‹routing demandçš„ä»»åŠ¡ï¼Ÿ

experiment

15benchmarks: 10 for training and 5 for testing  

run DREAMPlace [18] on each of the designs to generate placement solutions 

NCTU-GR 2.0 [2] to attain horizontal/vertical routing demand maps  , and set the congestion maps as a binary indicator according to whether the horizontal/vertical routing demand of the G-cell exceeds the circuitâ€™s capacity  

image-20241108150810402

image-20241108150803029

image-20241108150837509

å¯¹æ¯”å®éªŒï¼š

image-20241108151611413

image-20241108151757751

å¯è§†åŒ–ï¼š

image-20241108150918563

æ¶ˆèå®éªŒï¼š

image-20241108152104185

-NN Robustness improve-arXiv-2024- -UC-
background:

æœ€è¿‘çš„å·¥ä½œå·²ç»è¯æ˜ç¥ç»ç½‘ç»œé€šå¸¸æ˜¯å®¹æ˜“å—åˆ°ç²¾å¿ƒé€‰æ‹©çš„è¾“å…¥å°æ‰°åŠ¨çš„å½±å“ 

Our definition of imperceptibility is characterized by a guarantee that a perturbation to a layout will not alter its global routing  

recent work [10, 18] has demonstrated that image classifiers can be fooled by small, carefully chosen perturbations of their input  

image-20250102215202387

task

design two efficient methods for finding perturbations that demonstrate brittleness of recently proposed congestion predictors  

one potential approach to address the issues by modifying the training procedure to promote robustness

contribution

Painting on PIacement-predict the routing congestion-ACM-2019-GAN-

image-20241012153331855

image-20241012153541960

-DRC Hotspot Prediction-ISCAS-2021-CNN

-Routing Congestion Prediction-ASPDAC-2020-GAN

sliceFPGACong_ASPDAC20 (yibolin.com)

-predict #DRV, a macro placer-DATE-2019-CNN

Timing Prediction
Pre-Routing Timing Prediction
background
image-20241026164128136

relate work
TimingGCN-STA prediction-DAC-2022-GNN

the first workï¼

opensource

still relies on local net/cell delay prediction as auxiliary tasks  

no optimization, not fit the real-world scenario where timing optimization is taken into account  

PreRoutGNN-STA prediction-AAAI-2024-GNN

opensource

Multimodal Fusion-Restructure tolerant+CNN+Endpoint-wise Masking4Layout -DAC-2023-GNN+CNN-7nm RISCV

slice

Restructureï¼šé¢„æµ‹ç»ˆç‚¹çš„å»¶æ—¶ï¼Œä½†æ˜¯Timing Optä¼šæ”¹å˜ç½‘è¡¨ç»“æ„(end pointä¸å˜ï¼‰ã€‚å¯¹ä¸€ä¸ªPre-routingä»»åŠ¡æ¥è¯´ï¼Œè¾“å…¥çš„ç½‘è¡¨å’Œæœ€ç»ˆçš„ç½‘è¡¨ä¸ä¸€æ ·

netlist restructuring causes a mismatch between local input features and ground-truth features in the restructured sub-regions  

image-20241026173420844

As a result, prior local-view models can only be trained on the unchanged regions in a semi-supervised manner.  

In other words, the better the models fit on labeled (unreplaced) net/cell delays, the worse they fit on replaced regions and eventually on endpoint arrival time  

æ•°æ®é›†ï¼šåŸºæœ¬ä¿¡æ¯å’ŒTimingä¼˜åŒ–å¯¼è‡´çš„ç½‘è¡¨å˜åŒ–

average 40% nets and 21% cells are replaced during timing optimization  

timing optimization brings an average change of 59.6% to net delays
and 33.3% to cell delays  

image-20241026170120254

ä¸ºä»€ä¹ˆç”¨layoutä¿¡æ¯ï¼šSince most timing optimization techniques include gate insertion or gate sizing, placement should reserve space for subsequent timing
optimization. In other words, the timing optimizerâ€™s efficacy is tied closely to global layout information. The layout information plays a dominant role in determining the timing optimizerâ€™s impact since most optimization
techniques need space to be applied  

æ•´ä½“æ¨¡å‹

image-20241026184138343

ç»„æˆï¼šGNN+CNN+Endpoint-wise Masking  

Netlist(GNN):

image-20241026184646854

å’ŒTimingGCN-STA prediction-DAC-2022-GNNå¾ˆåƒ(æ²¡å‘ç°ä¸åŒ)

Layout(CNN+Endpoint-wise Masking)

image-20241026185621311

image-20241026193815323

ä¸‰ä¸ªç‰¹å¾ï¼šcell density, rectangular uniform wire density (RUDY), and macro cells region  

image-20241026190115449

Endpoint-wise Masking  

image-20241026194544366

å¯¹æ¯”å®éªŒï¼š

image-20241026200330616

image-20241026200838620

run timeå®éªŒ

image-20241026201203648

other
Ahead RC network-STA prediction-DAC-2022-?

TSteiner-STA prediction and refinement&steiner point refinement-DAC-2023-GNN-Yibo Lin

image-20241012155536218

Doomed Run Prediction-TNS prediction-ACM-2021-GNN+RNN

image-20241007121002859

not DL
image-20241026164603048The two-stage approaches [2], [3] first predict localnet/cell delays and then apply PERT traversals [5] to evaluate the global timing metrics, i.e., endpoint arrival time.  

Optimization
Timing
TSteiner - Steiner Points Opt-DAC-2023-GNN-CUHK

background

  å¯¹äºmulti-pin netéœ€è¦æ„å»ºsteiner treeæ¥è¿›è¡Œroutingï¼Œæ•…steiner treeä¸­steiner pointsä¹Ÿä¼šå½±å“routing

  FLUTE[3]æ˜¯å¸¸ç”¨çš„ç”Ÿæˆsteiner treeçš„ç®—æ³•ã€‚åœ¨ç”Ÿæˆsteiner treeåï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¿‘ä¸€æ­¥ä¼˜åŒ–steiner pointæ¥ä¼˜åŒ–timing

image-20241102112154369

the previous early-stage timing optimization works only focus on improving
early timing metrics. æå‡ºäº†è¯¸å¦‚netåŠ æƒå’Œå¯å¾®åˆ†æ—¶é—´ç›®æ ‡ç­‰ç­–ç•¥æ¥ä¼˜åŒ–æ—¶é—´, only focus on improving pre-routing timing metrics, which may have a considerable gap to signoff timing performance. æ–¯å¦é‚£ç‚¹æ›´åŠ é è¿‘å¸ƒçº¿é˜¶æ®µ(å’Œå¸ƒçº¿æ›´åŠ ç›¸å…³)

all the aforementioned works are not directly targeted at sign-off timing performance due to its high acquisition cost  

ä»»åŠ¡:

image-20241102111709494

In this paper, we focus on explicit sign-off timing optimization at the pre-routing stage to reduce the turnaround time

optimization framework is built to adjust Steiner point positions  for better sign-off timing performance iteratively  

The most popular Steiner minimum tree construction algorithms aim to minimize wirelength. Moreover, the Steiner point refinement is introduced to update the generated Steiner point positions for specific objectives, e.g., sign-off timing performance, while maintaining the two-pin net connections

å¯å‘:

we surprisingly find that the signoff timing performance could be significantly affected even by a random disturbance on Steiner point positions, as shown in Fig. 2.  

image-20241102114842155

Nevertheless, the impact of random moving is considerately unstable, and its average performance is slight (with a ratio close to 1.0).  æ‰€ä»¥å¯å‘æ‰¾åˆ°ä¸€ä¸ªå¥½çš„æ–¹æ³•æ¥æ›´æ–°æ–¯å¦çº³ç‚¹æ¥é™ä½TNS

åœ¨æœ€å¹¿æ³›ä½¿ç”¨çš„æŠ€æœ¯èŠ‚ç‚¹ä¸­ï¼Œä¸è·¯å¾„é•¿åº¦æœ€ç›¸å…³çš„å®šæ—¶åº¦é‡â€”â€”å‡€å»¶è¿Ÿï¼Œå¹¶ä¸èƒ½è§£é‡Šå¤§éƒ¨åˆ†çš„æ•´ä½“å®šæ—¶æ€§èƒ½. è¿™é‡Œç”¨çš„åˆå§‹åŒ–æ–¯æ³°çº³æ ‘çš„æ–¹æ³•çš„ä¼˜åŒ–ç›®æ ‡éƒ½æ˜¯è·¯å¾„é•¿åº¦æœ€çŸ­

contribution:

first  earlystage timing optimization framework   via Steiner point refinement

GNN

TSteiner framework is fully automated with an adaptive stepsize scheme and the auto-convergence scheme  

improves 11.2% and 7.1% on average (up to 45.8% and 43.9%) for WNS and TNS

æ¨¡å‹:

Steiner tree construction decomposes each multi-pin net into a set of two-pin
nets via additional Steiner points before global routing  to reduce the problem complexity

The proposed framework can be divided into two stages, sign-off timing gradient generation (Section III-A) and concurrent Steiner point refinement (Section III-B)  

image-20241102123009705

  image-20241102115937138

å’ŒTimingGCNç›¸æ¯”å°±æ˜¯å¤šäº†Steiner èŠ‚ç‚¹, ç„¶åå§ç¬¬ä¸€éƒ¨åˆ†çš„çš„node embeddingéƒ¨åˆ†åŠ ä¸Šäº†steinerçš„éƒ¨åˆ†

image-20241102121828217

å®é™…æ˜¯:image-20241102122509138

image-20241102122552273

ä¼˜åŒ–çš„æŒ‡æ ‡, WNSå’ŒTNSçš„åŠ æƒ

æ ¹æ®ä¼˜åŒ–æŒ‡æ ‡å¯¹æ–¯æ³°çº³ç‚¹åæ ‡å‚æ•°åšæ¢¯åº¦ä¸‹é™

image-20241102132825834

image-20250102200912287

ç›¸æ¯”ç®€å•çš„æ¢¯åº¦ä¸‹é™ï¼Œåªæ˜¯å‡å°äº†å¯¹ä¸åŒbenchmarkçš„æ‰‹åŠ¨å­¦ä¹ ç‡å¾®è°ƒ

æ•°æ®

image-20241102132430596

å®éªŒ

image-20241102132506821

image-20241102132555409

image-20241102132646602

image-20241102132734827

Marco Placement
-marco placement-nature-2021-RL+GNN-google

image-20241012160915238

image-20241012160933145

Placement
-Pin Accessibility+DRV prediction-DAC-2019-CNN-NTU
background:

Standard cells on the lower metal layers severely suffer from low routability due to high pin density, low pin accessibility, and limited routing resources.  

image-20250206153002501

It can be observed that the access points of pin B are blocked by the metal 2 (M2) routing segments routed from Pin A and Pin C, so an M2 short design rule violation (DRV) will be induced when dropping a via12 on Pin B. pin accessibility is not only determined by cell layout design but also strongly affected by adjacent cells    

å¯¹äºä¼ ç»Ÿæ–¹æ³•ï¼Œä¸¤ä¸ªç¼ºç‚¹ï¼š

Cell libraries provided by foundries should not be considerably redesigned because the optimized cell performance and manufacturability may be highly sensitive to cell layouts  

Deterministic approaches based on human knowledge have been shown to be less effective in advanced nodes for optimization problems such as DRV prediction and minimization because of the extremely high complexity through the overall design flow  

image-20250206154744610

It can be observed that most of the congested regions in the layout do not have DRVs, while some regions with DRVs are not so congested. ä½†æ˜¯æˆ‘æ„Ÿè§‰è¿˜æ˜¯æœ‰ç›¸å…³æ€§çš„ã€‚ä»–æ˜¯æƒ³è¯´æ˜congestionå‡ºç°çš„åœ°æ–¹ä¸ä¸€å®šæœ‰DRVï¼Œä½†æ˜¯æ²¡congestionçš„åœ°æ–¹å¯èƒ½å› ä¸ºpoor pin accessibilityå¯¼è‡´DRV

image-20250206154811206

ä¹Ÿæ˜¯è¯´æ˜ï¼šcongestionå‡ºç°çš„åœ°æ–¹ä¸ä¸€å®šæœ‰DRVï¼Œä½†æ˜¯æ²¡congestionçš„åœ°æ–¹å¯èƒ½å› ä¸ºpoor pin accessibilityå¯¼è‡´DRV

the two M2 shorts occur at the locations having the same pin pattern in the top cell-row and mid cell-row  

task:

DRV prediction, äºŒåˆ†ç±»

image-20250206190055066

pin accessibility optimization, ç»™ä¸€ä¸ªåˆæ³•åŒ–åçš„å¸ƒå±€ç»“æ„ï¼Œé€šè¿‡ç®—æ³•è¿›è¡Œå‡å°‘bad pin accessibilityçš„detailed placement

image-20250206190225309

å…¶å®ä¹Ÿæ˜¯ä¸€ä¸ªé¢„æµ‹æ¨¡å‹ï¼Œä¸€ä¸ªä¼˜åŒ–æ¨¡å‹

contribution:

first work to apply pin pattern as the input features of DRV prediction models.  

flow:

image-20250206191224771

model:

PPR&DFPPR:

image-20250206192506245

Model-guided Detailed Placement :

image-20250206195817013

image-20250206202610856

Dynamic Programming-based Placement Blockage Insertion  

image-20250206202803548

è¿˜ä¼šæ”¹æ–¹å‘ï¼Ÿ

Cell Displacement Refinement

data:

image-20250206192552413

Both the width and height of each pixel are set as the minimum spacing of the M1 layer in order to prevent a pixel from being occupied by two different pins. 

æ²¡çœ‹è§å…³äºbenchmarkçš„æè¿°

experiment:

image-20250206204743555

image-20250206205223899

shortcoming:

flow need routed designs to train, time 

The trained model is not necessarily applicable to other designs using different cells or different reference cell libraries  

å¯¹äºVLSIï¼Œä¸€è¡Œä¸€è¡Œï¼Œä¸€å¯¹ä¸€å¯¹è¿›è¡Œï¼Œå¾ˆæ…¢ï¼Ÿ

-Pin Accessibility+activ-ISPD-2020- -NTU+Synopsys
background:

With the development of advanced process nodes of semiconductor, the problem ofpin accesshas become one of the major factors to impact the occurrences of design rule violations (DRVs) due to complex design rules and limited routing resource  

supervised learning approaches extract the labels of training data by generating a great number of routed designs in advance, giving rise to large effort on training data preparation. the pre-trained model could hardly predict unseen data    

Unlike most of existing studies that aim at design-specific training, we propose a library-based model which can be applied to all designs referencing to the same standard cell library set.   

Due to the shrinking of modern process nodes of semiconductor, the pin access problem of standard cells has become more harder to be coped with, especially on the lower metal layers.  

image-20250206150405665

åœ¨è¿™ç§placementä¸‹ï¼ŒMetal1 pin A/Bç”±äºå„è‡ªå·¦å³ä¸¤è¾¹åœ¨Metal2æœ‰pinï¼Œè€Œä¸”åªèƒ½åœ¨é»„è‰²trackä¸‹æ¨ªå‘ç»•çº¿ï¼Œï¼ˆMetal1ä¸èƒ½ç»•çº¿ï¼Ÿï¼‰ï¼Œé‚£ä¹ˆPin A/Bé€šè¿‡Via12åå¿…å®šä¼šçŸ­è·¯

19å¹´å·¥ä½œ[5]çš„ä¸¤ä¸ªç¼ºç‚¹

flow need routed designs to train, time 

The trained model is not necessarily applicable to other designs using different cells or different reference cell libraries  

contribution:

first work ofcell library-basedpin accessibility prediction (PAP), which can be applied to predict other designs referencing to the same cell library set

applies active learning to train a PAP model  

the proposed cell library-based PAP model can be trained at the earlier stage in a process development flow: once the cell libraries are provided.  

Placement Optimization with Deep Reinforcement Learning- -ISPD-2020-RL+GNN-Google
PL GNN-Affinity Aware for ICC2- ISPD-2021-GNN-Atlanta
background:

Placement is one of the most crucial problems,  placement directly impacts the final quality of a full-chip design

multiple placement iterations to optimize key metrics(WL, timing), which is time-consuming and computationally inefficient, VLSI

thelogical affinity among design instancesdominates the quality of the placement

image-20241224115010379

logical affinity æºäºè¿™ç¯‡æ–‡ç« ï¼Ÿ

performing placement guidance requires in-depth design-specific knowledge,which is only achievable by experienced designers who knows the underlying data flows in Register-Transistor Level (RTL) well  

image-20241224114254672

K-meansåŸºç¡€ï¼š

image-20241224172053839

image-20241224172022162

task:

åŸºäºç½‘è¡¨æ•°æ®ï¼Œå’Œfloorplanç»“æœï¼ˆmarcoå·²ç»æ”¾å¥½ï¼‰

placement guidance(grouping information) for commercial placers ICC2, by generating cell clusters based on logical affinity and manually defined attributes of design instances  

our framework will determine thecell clusters in an unsupervised manner which serve as placement guidance in order to guide commercial placers to optimize the key metrics such as wirelength, power, and timing by placing cells with a common cluster together

flow:

image-20241224111801884

Two stages:

GNN do unsupervised node representation learning, (it is generalizable to any design)

weighted K-means clustering algorithm [3] to group instances into different clustersã€‚To find the optimal number of groups for clustering, we introduce the Silhouette score [19] and perform sweeping experiments to find the sweet spot  

K-meansç®—æ³•çš„åŸºæœ¬æ€æƒ³æ˜¯ï¼šé€šè¿‡è¿­ä»£çš„æ–¹å¼ï¼Œå°†æ•°æ®åˆ’åˆ†ä¸ºKä¸ªä¸åŒçš„ç°‡ï¼Œå¹¶ä½¿å¾—æ¯ä¸ªæ•°æ®ç‚¹ä¸å…¶æ‰€å±ç°‡çš„è´¨å¿ƒï¼ˆæˆ–ç§°ä¸ºä¸­å¿ƒç‚¹ã€å‡å€¼ç‚¹ï¼‰ä¹‹é—´çš„è·ç¦»ä¹‹å’Œæœ€å°ã€‚

image-20241007102413593

data

two multi-core CPU designsï¼š

image-20241224181733657

nf

design hierarchy : æ ¹æ®ç½‘è¡¨å±‚çº§. top/inst1/sky130_INV/A. (åŒæ—¶zero-padding)

image-20241224160726962

logical affinity of memory macros ï¼šlogical levels to memory macros ğ‘€ as features. because the logic to memory paths are often the critical timing paths  

image-20241224161329678

ef:

image-20241224171228803

model

GraphSAGE-basedï¼Œ two layers

image-20241224161923488

image-20241224162351812

Loss Function:

image-20241224170359079

image-20241224170818328

image-20241224170824860

Silhouette score  

ç”¨äºè¯„ä¼°åˆ†ç±»ç»“æœï¼Œæ‰«æåˆ†ç±»æ•°ç›®ï¼Œé€‰æ‹©æœ€é«˜çš„åˆ†çš„

image-20241224181002019

image-20241224181044251

image-20241224181052309

image-20241224181116187

experiment:

env:

2.40ğºğ»ğ‘ CPU   

NVIDIA RTX 2070   

16ğºğµ memory.  

PyTorch Geometric   

setting:

the placement of memory macros is achieved manually based on design manuals provided by the design-house  

Adam   

result

Louvainï¼šæ¯”è¾ƒå®éªŒå¯¹æ¯”æ¨¡å‹

image-20241224181627782

Question:

benchmarkå°‘

æ‰«æåˆ°çš„å°±é€‚ç”¨æ‰€æœ‰ï¼Ÿ

å¼€ç¯ï¼Ÿ

-Innovus PPA placement optimize-Neurips-2021-RL 
image-20241007103637165

image-20241007105134964

contribution:

image-20241224114117771

-GP Routability Opt-DAC-2021-FCN-CUHK(SitingLiu BeiYu)+Yibo Lin
background

flow

image-20241226160945080

three input features are extracted from the cell placement solution  

Through the inference of the pre-trained routability prediction model, we get the predicted congestion map.  

take mean squared Frobenius norm of this congestion map as the congestion penalty

image-20241226161200384

data

model

image-20241226161132128

Routing
global routing
backeground
gr 

image-20241128091217724

image-20241128091245240

drc

image-20241128093047653

image-20241128093058137

PROS-Routability Optimization-ICCAD-2020-FCN-CNHK+Cadence
background

image-20241128091405687

image-20241128091759855

task

congestion predictor and parameter optimizer

only the data from the placement  

it can optimize the cost parameters before the first routing iteration of GR and thus can give a better GR solution with less congestion.  

contribution

with negligible runtime overhead  

plug-in

can be embedded into the state-of-the-art commercial EDA tool (Cadence Innovus v20.1)   

model

image-20241219171627049

data

19 different industrial designs  

image-20241219165446998

é€šè¿‡ä¸åŒçš„placementå‚æ•°å’Œæ—‹è½¬ï¼ˆCNNåŸç†ï¼‰ï¼Œä¸€å…±æœ‰1664 design cases in total.  

Feature Extraction  

Horizontal/Vertical track capacity map  

Cell density map

Flip-flop cell density map  

Fixed cell density map  

Cell pin density map  

Pin accessibility map  

image-20241219161307835

Horizontal/Vertical net density map  

Small/Large-net RUDY map  

image-20241219161336920

Pin RUDY map

a combination of cell pin density map and large-net RUDY
map  

Label Generation  

image-20241219162403381PROS does not need very detailed congestion map   

two-step smoothening process to convert raw data to desirable congestion labels  

help to make the prediction task easier  

if there are at least six congested G-cells out of the eight in the surrounding of a center G-cell Ğ´, Ğ´ will be labeled as congested  

image-20241219162837909

ä¼˜åŒ–åŸç†

è¿™ä¸¤ä¸ªå€¼åœ¨cadenceæ€ä¹ˆæ”¹çš„? cadenceä¼ä¸šå†…éƒ¨è‡ªå·±å¼„çš„ï¼ˆè¿™æ˜¯cadenceçš„æ–‡ç« ï¼‰ï¼Ÿ

image-20241219165904742

image-20241219165912121

model

image-20241219163417043

experiment

image-20241219172158774

image-20241219172205431

image-20241219172212018

image-20241219172620444

PROS 2.0 - Routability Opt+Route WL estimation-Trans-2023-CNN-CNHK+Cadence
background

the amount of routing resources on a design is limited.   

The quality of a GR solution has a great impact on that of the resulted DR routing solution  

Congestion in a GR solution is one of the major causes of DRC violations in the DR
solution since most of DRC violations are due to overcrowded wires and vias [1], [2]  

a better GR solution with less congestion is needed to lower the probability of getting DRC violations in advance. 

if the initial GR solution is not good and has a lot of congestion, the GR tool can hardly tackle the problem by rip-up and reroute.  

placement engines [3]â€“[5] which take routing congestion into consideration are applied  

FCN:FCNå¸¸ç”¨äºå›¾åƒä¸­çš„æ¯åƒç´ åˆ†ç±»é—®é¢˜ã€‚é‡‡ç”¨ä»»æ„è¾“å…¥å¤§å°ï¼Œå¹¶äº§ç”Ÿå¤§å°å®Œå…¨ç›¸åŒçš„è¾“å‡ºã€‚GRæ‹¥å¡é¢„æµ‹ä¹Ÿå¯ä»¥è¢«è§†ä¸ºä»»æ„å¤§å°çš„èŠ¯ç‰‡è®¾è®¡ä¸Šçš„åƒç´ äºŒè¿›åˆ¶åˆ†ç±»é—®é¢˜ï¼ˆæ‹¥å¡ä¸å¦ï¼‰ã€‚å› æ­¤ï¼ŒåŸºäºFCNçš„é¢„æµ‹å™¨å¯ä»¥è‡ªç„¶åœ°åº”ç”¨äºPROSã€‚

task:

stage: post-placement, pre-route

FCN based GR congestion predictor, use the predicted GR congestion to optimize the cost parameters of GR. 

predictor based parameter optimizer to generate a better GR solution. GR tools are driven by the cost parameters stored in each G-cell. When arriving at a G-cell g, the tool will compute the cost, called moving cost, to move to each of its neighboring G-cells and push these costs into a heap. With optimized cost parameters in G-cells, the GR tool can find better paths and allocate the routing resources to each net more smartly. PROS optimizes two types of cost parameters based on the prediction result, including overflow cost and wire/via cost  .  PROS will adjust the cost parameters in the projected congestion regions on all layers  

overflow cost

wire/via cost: divided into two groups (small/large) according to their BBox sizes. 

Increasing the wire/via cost for small nets may be useless for congestion reduction and it may even increase the wire length or create new congestion due to detours out of the potential congestion region.  

In contrast, increasing the wire/via cost for large nets can be helpful since
they can select another route within its BBox to completely avoid the potential congestion region

CNN based  wirelength estimator  ,  By multiplying the predicted wirelength ratio and the precomputed FLUTE wirelength  (è®­ç»ƒä¸€ä¸ªç³»æ•°). The lack of consideration of routing congestion in traditional methods is due to the dif ficulty of quickly obtaining accurate congestion estimation at the placement stage

contribution:

plug-in for Innovus:  it can avoid extra runtime overhead of feature preparation  

industrial design suite   

advanced technology node  

SOTA

high accuracy

first work that 

utilizes the information of GR congestion to estimate routed wirelength at the placement stage  

PROS does not change a lot for the original EDA steps  

Overall Flow :

image-20241225231457615

image-20241225231740032

åˆ†ç±»å’Œå›å½’

image-20241225231939553

F is the feature number.  

X~WL~ has two features:  These two features will be resized to 128 Ã— 128 before prediction  

the predicted congestion map 

the cell pin density map   

data

feature F 

Horizontal/Vertical Track Capacity Map  

Cell Density Map  

Flip-Flop Cell Density Map

Fixed Cell Density Map  

Cell Pin Density Map  

Pin Accessibility Map  

image-20241226095003879

Horizontal/Vertical Net Density Map

image-20241226095234394

Small/Large-Net RUDY Map  

image-20241226095702886

Pin RUDY Map ?

label

congestion label  pre-process

PROS does not need a very detailed congestion map

image-20241226100513980

æœ€åè¿˜æ˜¯ä¸ºäº†ä¼˜åŒ–æœåŠ¡çš„

model

image-20241226133238155

DC: get more local information, but more GPU usage(acceptable)

SUB: w*h*4c â€“>2w*2h*c.

Compared with bilinear upsampling which is not trainable, subpixel upsampling can learn to recover the local information.

Compared with deconvolution, subpixel upsampling is parameter free, so
it will not significantly increase the training difficulty.  

image-20241226133719030

dataset

industrial benchmark suite and  DAC-2012  benchmark suite(19ä¸ª benchmark)

industrial benchmark suite é€šè¿‡11ç§ä¸åŒå¸ƒå±€å‚æ•°ï¼Œç¿»è½¬å’Œæ—‹è½¬ï¼Œåˆ¶é€ äº†ä¸€å…±æœ‰1664ä¸ª(çº¦ç­‰äº19*11*8)benchmark

DAC-2012 20 different placements  

(4, 4, 4, 4, 3)  5æŠ˜äº¤å‰éªŒè¯

image-20241226134314062

image-20241226134322968

experiment

env

Tensorflow  

Intel Xeon CPUs at 2.2 GHz  

256 GB memory  

NVIDIA TITAN V GPU  

setting

Adam

One entire training process of the congestion predictor has 25 training epochs! è¿™ä¹ˆå°‘ï¼ˆæ”¶æ•›å¥½å¿«ï¼‰  

image-20241226135108986

congestion classification prediction

image-20241226135344696

image-20241226135500109

compare with PROBABILISTIC METHODS  

image-20241226135607227

image-20241226135730697

image-20241226135756327

DRä¼˜åŒ–ç»“æœ

image-20241226140031433

çº¿é•¿ä¼°è®¡

image-20241226140057750

image-20241226142425570

image-20241226142433618

Runtime

image-20241226142533340

image-20241226142539173

detail routing
background
image-20241028220857482

image-20241028221200277

-Detailed Router-DATE-2021-RL
image-20241012161419196

DPRouter-Detail Routing(package design) Opt+net order decision-ASPADC-2023-RL(MARL)-diagonally route
image-20241027101634534

BackGround

most time-consuming stages in the package design flow  

package designs have fewer layers; thus, we need to prevent net crashing cautiously  

contrbution:

redefine the routing area and shrink the routing problem by dividing the entire design into non-overlapping boxes  

use DRL, not heuristic

prove the number of design rule violations (DRVs), wirelength and layout pattern.  

task

2-pin nets  

image-20241027104527603

Initial routing: ignores the number of bends and allows design rule violations  

image-20241027104906544

Model

multi-agent deep reinforcement learning (MARL) task [15] for asynchronous routing planning between nets. We regard each net as an agent, which needs to consider the actions of other agents while making pathing decisions to avoid routing conflict  

image-20241027104558097

image-20241027105909572

route and slide the window repeatedly. advantage of box:process every box independently  

sequential routing  

image-20241027134657161

image-20241027133917659

image-20241027133231542

image-20241027133826865

the repulsion point will be moved from the inner ring to the outer one until the box is successfully routed.   

å…·ä½“ç®—æ³•ï¼š

image-20241027141238708

sequential routing  

image-20241027142631796

image-20241027143243104

image-20241027144931328

Refinement

image-20241027144108460

-Detail routing+match+Opt-ISPD-2023-RL+GNN-FinFET 
background:

cutom circuits: a custom detailed router cannot adopt specialized layout strategies for specific circuit classes like human layout experts  

image-20241028221540078

image-20241028224206180

image-20241028222447134

ä¸€ç›´åœ¨å¼ºè°ƒmatchçš„é—®é¢˜ï¼š

image-20241028224639124

contribution

opt roouting, FinFET, sign-off solution

å¼‚æ„å›¾

A rip-up and re-routing scheme  

can easily adapt to future design constraints  

three categories  of routing methodologies  

Template-based methods 

manual design  

suffers from scalability issues   

Simulation-based techniques  

provide accurate performance feedback and can be generalized to consider various performance metrics (e.g., phase
margin, power dissipation) across circuit classes  

long execution time and resource-hungry computations  

Constraint-based approaches  

widely adopted in existing custom routing studies  

PR Tools
Placement and routing (PnR) is the most time-consuming part of the physical design flow

image-20241114120146641

Placer
Chip Placement with Deep Reinforcement Learning-marcro-arXiv-2020-RL
Differentiable-Timing-Driven Global Placement-global placement-DAC-2022-GNN-
Polar 2.0
 An effective routability-driven placer

cells that are estimated to have high congestion are spread out and inflated to distribute routing demand more evenly.  

NTUPlace3
DeepPlace
flow

RePlAce--TCAD-2018-
DREAMPlace-GP-DAC+TCAD+ICCAD+DATE-2019~2023
introduction

Over 30X speedup over the CPU implementation (RePlAce) is achieved in global placement and legalization on ISPD 2005 contest benchmarks

DREAMPlace runs on both CPU and GPU. If it is installed on a machine without GPU, only CPU support will be enabled with multi-threading.

DREAMPlace also integrates a GPU-accelerated detailed placer,ABCDPlace, which can achieve around 16X speedup on million-size benchmarks over the widely-adopted sequential placer NTUPlace3 on CPU.

Publications

Yibo Lin, Shounak Dhar, Wuxi Li, Haoxing Ren, Brucek Khailany and David Z. Pan, "DREAMPlace: Deep Learning Toolkit-Enabled GPU Acceleration for Modern VLSI Placement", ACM/IEEE Design Automation Conference (DAC), Las Vegas, NV, Jun 2-6, 2019 (preprint) (slides)

Yibo Lin, Zixuan Jiang, Jiaqi Gu, Wuxi Li, Shounak Dhar, Haoxing Ren, Brucek Khailany and David Z. Pan, "DREAMPlace: Deep Learning Toolkit-Enabled GPU Acceleration for Modern VLSI Placement", IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems (TCAD), 2020

Yibo Lin, Wuxi Li, Jiaqi Gu, Haoxing Ren, Brucek Khailany and David Z. Pan, "ABCDPlace: Accelerated Batch-based Concurrent Detailed Placement on Multi-threaded CPUs and GPUs", IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems (TCAD), 2020 (preprint)

Yibo Lin, David Z. Pan, Haoxing Ren and Brucek Khailany, "DREAMPlace 2.0: Open-Source GPU-Accelerated Global and Detailed Placement for Large-Scale VLSI Designs", China Semiconductor Technology International Conference (CSTIC), Shanghai, China, Jun, 2020 (preprint)(Invited Paper)

Jiaqi Gu, Zixuan Jiang, Yibo Lin and David Z. Pan, "DREAMPlace 3.0: Multi-Electrostatics Based Robust VLSI Placement with Region Constraints", IEEE/ACM International Conference on Computer-Aided Design (ICCAD), Nov 2-5, 2020 (preprint)

Peiyu Liao, Siting Liu, Zhitang Chen, Wenlong Lv, Yibo Lin and Bei Yu, "DREAMPlace 4.0: Timing-driven Global Placement with Momentum-based Net Weighting", IEEE/ACM Proceedings Design, Automation and Test in Eurpoe (DATE), Antwerp, Belgium, Mar 14-23, 2022 (preprint)

Yifan Chen, Zaiwen Wen, Yun Liang, Yibo Lin, "Stronger Mixed-Size Placement Backbone Considering Second-Order Information", IEEE/ACM International Conference on Computer-Aided Design (ICCAD), San Francisco, CA, Oct, 2023 (preprint)

Architecture

image-20241211185233352

image-20241211185244415

flow

Router
background
image-20241114151714903

Global routing plays a crucial role in electronic design automation (EDA), serving not only as a means of optimizing routing but also as a tool for estimating routability in earlier stages such as logic synthesis and physical planning.   

Optimal(æœ€ä¼˜) global routing is a NP-complete problem.  

image-20241114155408683

DRLï¼š

image-20241114163851523

image-20241114164422672

image-20241114164432478

image-20241114164629770

image-20241114171359019

ä¼ ç»Ÿ2dGR flow

image-20241122111320412

image-20241122111224572

image-20241122111232778

image-20241122113559774

3dGR flow

GR_outdated
FLUTE
FLUTE is an RSMT construction algorithm adopting a look-up table approach, which is both fast and optimal for low-degree nets. However, FLUTE is unaware of routing congestion.  

image-20241116114652698

ä¸‹é¢æ˜¯ä¸€ç³»åˆ—FLUTEå’ŒåŸºäºFLUTEçš„æ”¹è¿›

image-20241116114634422

FastRoute1.0â€”2006
roposed a simple way to construct congestion driven Steiner tree and an edge shifting technique to further refine it  

fastroute 2.0-Monotonicâ€“2007
monotonic routing to explore all shortest routing paths for two-pin connections.   

task

image-20241114191327215

flow

image-20241114205659503

image-20241115160208134

fastroute 3.0-virtual capacity-ICCAD-2008-
fastroute 4.0-via min tree+3 bending-ASPDAC-2009-
image-20241116121010565

image-20241115160433890

image-20241115160445784

image-20241116105606149

image-20241116121317660

image-20241116121311506

å±‚åˆ†é…

image-20241116124343911

?

image-20241116125839541

image-20241116125830996

MaizeRouter-
2nd place of ISPD 2007 contest 2D GR

1st place of ISPD 2007 contest 3D GR

BoxRouter 1.0
3rd place of ISPD 2007 contest 2D GR

2nd place of ISPD 2007 contest 3D GR

integer linear programming (ILP)  based

FGR-3d-TCAD-2008-
1st place of ISPD 2007 contest 2D GR

3rd place of ISPD 2007 contest 3D GR

-Layer assignment+Via minization-Trans-2008-DP-NTHU
Congestion-Constrained Layer Assignment for Via Minimization in Global Routing

CUGRâ€™s rely work

ISPD07 conteståçš„ä¸€ä¸ªè·Ÿè¿›å·¥ä½œ

ä¹Ÿæ²¡æåˆ°maze routing

æ²¡å®šä¹‰wire cost, åœ¨æ¯ä¸€å¯¹GCellä¹‹é—´layer assignment, æ…¢ï¼Ÿ

ç¬¬ä¸€æ¬¡ç”¨DP?

background:

there are two main approaches  

image-20250208202630352

3D: route all nets directly on the multilayer solution space. Because this approach directly generates a multilayer global routing result, it can take the via cost into account during construction. However, this method may cost too much CPU time with a large problem size. (ç°åœ¨éƒ½ç”¨GPUåšå¹¶è¡Œäº†ï¼Œè¿™ç§æ–¹æ³•å°±å˜å¤šäº†)

such as 

image-20250208201732440

2D + layer assigment: The other approach is to first compress a multilayer grid graph into a one-layer grid graph, then use a one-layer router to solve the one-layer global routing problem, and finally perform layer assignment to assign each wire in the multilayer grid graph

image-20250208202642473

The edges corresponding to vias disappear in the one-layer grid graph. The capacity of each edge in the one-layer grid graph is obtained by accumulating the corresponding edge capacities in the three-layer grid graph

This approach can take advantage of many current full-fledged one-layer routers, e.g., [2]â€“[4], and use an affordable run time to generate an initial one-layer routing result. æœ¬æ–‡ä¸»è¦é’ˆå¯¹layer assignment. æ³¨æ„layer assignment æ˜¯å¯¹äºŒç»´çš„æ‰€æœ‰è¾¹è¿›è¡Œå±‚åˆ†é…ã€‚

vias not only degrade the reliability and the performance of a design but also increase the manufacturing cost.  

previous workâ€™s layer assignment use greedy heuristics [8] or time-consuming integer linear programming methods [9]  to minimize the via cost.  

åƒè¿™ç§ä¸²è¡Œçš„è¿˜æ˜¯è¦è€ƒè™‘net order, è¶Šæ—©å¸ƒçº¿çš„netè¶Šä¸ä¼šæ‹¥å¡ï¼Œnet orderå¾ˆé‡è¦

task and contribution:

è¿™ç¯‡æ²¡æœ‰è€ƒè™‘ä¼˜å…ˆæ–¹å‘ï¼ˆTo simplify the presentation of our algorithm, we do not make any assumption about the preferred routing direction for each layer in the layer assignment problem.ï¼‰ä¸è¿‡ä¹Ÿè¯´æ˜äº†è¿™ä¸ªå·¥ä½œèƒ½å¤Ÿå¾ˆç®€å•å¼•ç”¨åˆ°è€ƒè™‘ä¼˜å…ˆæ–¹å‘çš„æƒ…å†µ

follow ISPD07 contest, å‡è®¾viaçš„capacityæ˜¯æ— é™çš„ï¼ˆCUGRä¸­æ˜ç¡®äº†ä¸è¿›è¡Œè¿™ç§å‡è®¾ï¼‰

based on a one-layer routing result

minimize via cost, WL and congestion overflow

propose a polynomial-time algorithm: first generate net order , then solves the layer assignment problem

can improve 3 winner of ISPD07 contest

model  

COngestion-constrained Layer Assignment (COLA)â€™s submodule

Net order generation

The net order has a direct influence on the utilization of routing resources, so it is one of the key parts of COLA.   

å¯¹netè¿›è¡Œæ‰“åˆ†å†³å®šorder

image-20250208220017618

æ³¨æ„ï¼Œçº¿é•¿è¶ŠçŸ­ï¼Œåˆ†æ•°è¶Šé«˜ï¼Œnetè¶Šåº”è¯¥å…ˆå¸ƒçº¿ã€‚è§£é‡Šï¼š

image-20250208221143998

Eemove Cycles

Arbitrarily remove.

ï¼ˆä¸ºä»€ä¹ˆæ˜ å°„åˆ°ç¬¬ä¸€å±‚ä¼šæœ‰cyclesï¼Ÿåˆå§‹æ˜¯æ€ä¹ˆè¿èµ·æ¥çš„ï¼Ÿæ²¡è¯´ï¼ŸFLUTEç®—æ³•æ˜¯08å¹´æ‰å‡ºæ¥ï¼Œå¯èƒ½å½“æ—¶è¿˜æ²¡ç”¨ä¸Šï¼‰

image-20250208222041475

Single-net layer assignment  ï¼ˆSOLA+APECï¼‰

SOLA(Singlenet Optimal Layer Assignment)  

determines an optimal layer assignment result without considering congestion constraints for a given net  

dynamic programming technique

ä¸è€ƒè™‘æ‹¥å¡ï¼Œè¿™ä¸ªæ–¹æ³•èƒ½å¾—åˆ°æœ€å¥½è´¨é‡

step:

01: for tree in layer 1, random select a pin as root, then use DFS or DFS to get a queue, so get the edge order. It become a DAG

image-20250208223956201

02: å®šä¹‰å›¾5(c)ä¸­, açš„çˆ¶èŠ‚ç‚¹æ˜¯p2ï¼Œå®šä¹‰mvc(v, r)ï¼ˆminimum via costï¼‰

image-20250209140741895

03: 

	for pins who have not child, mvc:

image-20250209143711603

	for pins who have child and not root:

	è¿™ä¸ªå…¬å¼å…¶å®å°±æ˜¯ä¸ºäº†ç¡®å®šä¸‹æ¯ä¸ªç‚¹ä¸‹ä¸€æ­¥çš„layeråœ¨å“ªé‡Œã€‚æ¯”å¦‚ç®—å‡ºæœ€å°æ˜¯mvc(v, 1), é‚£ä¹ˆe_(v, ch(e))å°±åœ¨ç¬¬rå±‚

image-20250209143753884

	for root:

image-20250209145157487

the difference is excluding r in âˆ†  

because mvc(v, r) does not depend on the value of r when v 

is the root, we have mvc (v, 1) = mvc(v, 2) = Â· Â· Â· = mvc(v, k)

APEC(Accurate and Predictable Examination for Congestion constraints)  

can detect and prevent any congestion constraint violation in advance  

prevention condition:

image-20250209153339230

å¦‚æœå­˜åœ¨ä¸€ä¸ªåœ¨layer1ä¸Šå‹ç¼©çš„è¾¹ä¸æ»¡è¶³è¿™ä¸¤ä¸ªconditionï¼Œé‚£ä¹ˆè¿™æ¡è¾¹çš„layer assignmentï¼ˆSOLAï¼‰ç»“æœå°±ä¸å¯èƒ½æ»¡è¶³congesion

SOLA+APEC always finds a layer assignment result satisfying both prevention conditions for each net  

COLA

image-20250209153812734

	

data:

six-layer benchmarks from ISPDâ€™07

GRIP-3d+IP-DAC-2009
åŸºäºæ•´æ•°è§„åˆ’

3d: solve the 3D problem directly on the 3D routing grids,  

slow: Although theoretically the direct 3D technique should produce better solutions, in practice it is less successful in both solution quality and runtime than 2D routing with layer assignment  â€“citeâ€“> [Fastroute4.1]

slow: Although we see solutions with shorter wirelength generated by full-3D concurrent approach like GRIP [21], that solution quality is achieved by impractically long runtime   â€“citeâ€“> [Fastroute4.1]

MGRâ€“ICCAD-2011

multi-level ï¼ˆcoarsened  and fine-gainedï¼‰

FastRoute4.1-an efficient and high-quality global router-2012
https://dl.acm.org/doi/abs/10.1155/2012/608362

background

FastRoute is a global routing tool for VLSI back-end design. It is based on sequential rip-up and re-route (RRR) and a lot of novel techniques. FastRoute 1.0 first uses FLUTE to construct congestion-driven Steiner trees, which will later undergo the edge shifting process to optimize tree structure to reduce congestion. It then uses pattern routing and maze routing with logistic function based cost function to solve the congestion problem. FastRoute 2.0 proposed monotonic routing and multi-source multi-sink maze routing techniques to enhance the capability to reduce congestion. FastRoute 3.0 introduced the virtual capacity technique to adaptively change the capacity associated with each global edge to divert wire usage from highly congested regions to less congested regions. FastRoute 4.0 proposed via-aware Steiner tree, 3-bend routing and a delicate layer assignment algorithm to effectively reduce via count while maintaining outstanding congestion reduction capability. FastRoute 4.1 simplifies the way the virtual capacities are updated and applies a single set of tuning parameters to all benchmark circuits.

model

image-20241211103407310

flow

image-20241211103347856

NTHU Route 1.0- -TVLSI-2010-
image-20241115155033412

NTHU Route 2.0- -TCAD-2013
2D

NCTU GR 1.0-3D-congestion relaxed layer assignment- 2011-
it improved the scheme to estimate the realtime congestion more accurately by using a history term that will gradually wear off as the number of iterations  increases if the overflow disappears.   

NCTU GR 2.0-Multithreaded Collision Aware- CAD-2013-
people.cs.nycu.edu.tw/~whliu/NCTU-GR.htm

PengjuY/NCTU-GR2: This is a binary file of NCTUgr2, which is a global router

net-level parallel method 

2D

BoxRouter 2.0
background

task

æ˜¯ä¸€ä¸ª2dçš„

æ•´æ•°è§„åˆ’

image-20241115155857782

OGRE- new cost function- -2019- -
Open source!

LEF/DEF-based

3D

ç”¨çš„æ˜¯è€æ–¹æ³•ï¼Œä¸è¿‡è§£é‡Šçš„æŒºæ¸…æ¥šçš„

components by a group of undergraduate students as a course project.

GR_Adv
-DRL method-2019-DRL-
task

DRL(DQN) for global route

have not use real world design

example:

	from A to B

	read means over flow

image-20241114192638647

image-20241114193438871

pipeline

image-20241114192055104

model

state: 

(pos_x/y/z, distance_x/y/z, å‘¨å›´çš„capacity,  )è¿™ç§ç¼–ç æ–¹æ¡ˆå¯ä»¥è¢«è§†ä¸ºå½“å‰çŠ¶æ€ã€å¯¼èˆªå’Œæœ¬åœ°å®¹é‡ä¿¡æ¯çš„æ··åˆ

action: ä¸Šä¸‹å·¦å³å‰å

rewardï¼š

image-20241114200225347

image-20241114200512353

contribution

first deep learning model for global routing

-only CNN-DAC-2020-CNN(VAE)-
no experiment!

åªç”¨CNNåˆ†ç±»ç»“æœä¸ä¼šå¥½å§

ä¸çŸ¥é“æ˜¯ä»€ä¹ˆç±»å‹çš„æ–‡ç« ï¼Œåªç”¨äº†ä¸¤é¡µ

background

is approach treats the global routing problem as an image processing problem and solves it with a deep learning system  

image-20241114161657070

dataset

ISPDâ€™98 ibm01 64x64 circuit  

model

image-20241114162111775

-DRL-arxiv-2021-JP
SPRoute 1.0: A Scalable Parallel Negotiation-based Global Router-ICCAD-2019
task

åŸºäºnet-levelå¤šçº¿ç¨‹çš„å¹¶è¡ŒåŠ é€Ÿè¿·å®«ç®—æ³•

negotiation-based rip-up and reroute two-phase maze routing

resolves livelock issue   

open source

introduced a concept called soft capacity to reserve routing space for detailed routing and explored several parallelization strategies to speed up global routing.  

background

æ€»ä½“

image-20241118140649906

In many global routers, maze routing is the most time-consuming stage.  

image-20241118141048410

challenge

image-20241118144548718

image-20241118144701004

å› ä¸ºè¿™ä¸ªç°è±¡ï¼Œå¤šçº¿ç¨‹åè€Œæ…¢äº†

image-20241118144924768

åŸç†

Galois system  

image-20241118150854386

Net-level Parallelism  

Fine-grain Parallelism  

data

ISPD 2008  contest

SPRoute 2.0- detailed routability driven-ASP DAC-2019-
ç‰¹ç‚¹

åŸºäºå¤šçº¿ç¨‹çš„å¹¶è¡ŒåŠ é€Ÿ

2D

å¼€æºï¼šasyncvlsi/SPRoute: A parallel global router using the Galois framework

CUGR-3D pattern+Multi level maze routing+patching-DAC-2020-CUHK
ICCAD 2019 Contest First Place

open source!

3d+å¤šçº¿ç¨‹+

è¿™ä¸ªæ–‡ç« æ²¡æœ‰è®¨è®ºprefer direction

å¤šçº¿ç¨‹ä½“ç°åœ¨å“ªé‡Œï¼Ÿ

æ³¨æ„ï¼šè¿™ç§æ ¼å¼çš„GRè¾“å‡ºå¯ä»¥é€‚é…Innovus

time-complexity of 3D pattern routing is $\mathcal{O}(L^4|V|)$

compare with Trans-2008, CUGR reduces the complexity to $\mathcal{O}(L^4|V|)$ by selecting the root carefully so that each vertex will have at most three preceding vertices instead of four.  æ³¨æ„ï¼Œè¿™é‡Œè¯´ ç›¸æ¯”Trans-2008çš„$\mathcal{O}(L^5|V|)$ ï¼Œå®ƒçš„å¤æ‚åº¦æ˜¯$\mathcal{O}(L^4|V|)$ ï¼Œæ„Ÿè§‰æ˜¯æ”¾åœ¨äº†Trans-2008è¿›è¡Œä¸è½¬å¼¯çš„DP-based layer assignmentæ–¹æ³•ä¸Šäº†ï¼Œå®é™…ä¸ŠæŒ‰ç…§æœ¬æ–‡è¯´çš„æ–¹æ³•ï¼Œç†è®ºä¸Šæ˜¯$L * L^{2*3}|V|$ï¼Œå› ä¸ºCUGRæ¯æ¬¡æ˜¯å¯¹ä¸€ä¸ªL patternä¸ºå•ä½è®¡ç®—mvc,æ—¶é—´å¤æ‚åº¦æ˜¯$2*L*L$.ç¡®å®æ˜¯$L^4$, CUGRå¯¹ä¸€ä¸ªL patternåˆ†äº†ä¸¤éƒ¨åˆ†è®¡ç®—mvcæ²¡ä¸€éƒ¨åˆ†æ—¶é—´å¤æ‚åº¦æ˜¯$L*2$

background

image-20241122110742970

A common strategy of doing 3D global routing, as adopted by NCTU-GR 2.0 [5], NTHU-Route 2.0 [6], NTUgr [7] and FastRoute 4.0 [8], is to first compress the 3D grid graph into a 2D grid graph and perform 2D global routing.   

directly route the nets in a 3D grid graphï¼šFGR [10] , GRIP [11] , MGR [12]  

Traditional pattern routing generates 2D topologies only, while our proposed 3D pattern routing directly generates 3D topologies without the need of an extra layer assignment stage

ä½¿ç”¨DRç»“æœè¿›è¡Œå¤šè§’åº¦metrics è¯„ä¼°ï¼š

image-20241122113634633

task

detailed-routability-driven  directly-3d multi thread GR

contibution

probability-based cost scheme

minimizing the possibility of overflow after detailed routing

3D pattern routing technique (2D pattern routing + layer assignment)(å‰é¢åˆè¯´directly in the 3D space?)

without overflow even only L shape patten routing

pre-work[15] æ˜¯å…ˆåœ¨2dä¸Šè¿›è¡Œpattern routing, ç„¶åè¿›è¡Œlayer assignment, è¿™é‡Œæ˜¯ç›´æ¥åœ¨3dè¿›è¡Œpattern routing. 3d pattern routing can avoid loss of accuracy caused by compressing 3D grid graph to 2D  

multi-level maze routing:

coarsened level â€“> searches for a region with the best routability. first narrows the search space to a smaller region  

fine-grained level â€“> searches for a lowest cost solution within the region

patching mechanism

further improve the detailed routability

flow

image-20241122123825463

In 3D pattern routing (inital routing), the nets are broken down into two-pin nets, and a dynamic programming based algorithm will route the two pin nets sequentially using Lshape patterns and stacking vias at the turns.  

In the multi-level 3D maze routing phase, the grid graph is coarsened to shrink the routing space, and maze routing is first performed in the coarsened space with an objective to find a routing region with the highest routability.   A fine-grained maze routing will then search for a lowest cost path within the region.  use its patching mechanism here.

model

Gcellä¹‹é—´çš„å®¹é‡ç­‰äºtrackï¼Œä¸€èˆ¬GRè¡¨å¾viaçš„å®¹é‡æ˜¯æ— é™çš„ï¼Œä½†æ˜¯åœ¨æœ¬æ–‡ä¸­ä¸æ˜¯

three base definition:

resource = capacity - demand

è¿™ä¸‰ä¸ªå˜é‡åœ¨GCellå’Œwire_edgeä¸Šéƒ½æœ‰ç‰¹å¾ï¼Œä¹Ÿå°±æ˜¯è¯´æœ‰6ä¸ªå€¼

resource èƒ½å¤Ÿç›´æ¥è¡¨ç¤ºæ‹¥ç¨‹åº¦

image-20241122130729921

image-20241122130736928

cost scheme

ä¸»è¦åˆ†æˆwireå’Œviaä¸¤éƒ¨åˆ†ï¼š

image-20241122130626631

wire cost:

image-20241122130653693

wlis wire lenght cost

eo is expected overflow cost, where uoc is hyper parameter, The larger  d(u, v) is, the more likely it is to be congested. is accurate if the DR adopts the simplest strategy of picking a track randomly to route. However, most well designed detailed routers will do much better than random selection.  

lg(u,v) is a variable to refine d(u, v). â€œ+1â€ æ˜¯ä¸ºäº†å€¼åŸŸåœ¨ï¼ˆ0ï¼Œ1ï¼‰è¡¨ç¤ºæ¦‚ç‡ã€‚ slope is hyper parameter. When the resources are abundant, there is almost no congestion cost, but the cost will increase rapidly as the resources are being used up and will keep increasing almost linearly after all the resources are used  

image-20241122130807532

via cost:

thanks to our 3D pattern routing strategy, a via cost scheme can be embedded to reflect the impact.  

image-20241122130701652

uvc is hyper parameter. 

å…¬å¼ï¼ˆ5aï¼‰ä¸ºä»€ä¹ˆè¦â€œ+1â€

Initial Routing / 3D Pattern Routing

use FLUTE first (not congestion awared)

use edge shifting (described in FastRoute) to alleviate  congestion.

randomly choose one node in net, use DFS to get a queue and then get a DAG

ç±»ä¼¼[15]ï¼ŒåŠ¨æ€è§„åˆ’é€‰æ‹©costæœ€å°çš„3d L patternï¼Œæ¯ä¸ªL patternæœ‰(2 * L * L)ç§å¯èƒ½

image-20250209165125803

æœ€ååœ¨rootå¤„å¾—åˆ°æœ€ç»ˆçš„ç»“æœ

Multi-level 3D Maze Routing  

maze route planing

aims at finding a smaller but highly routable search space

compress a block of G-cells (5x5 in our implementation), use avg to descripe capacity, demand, resource

cost function:

image-20250209172954350

å¾—åˆ°ç°è‰²ç²—ç½‘æ ¼ï¼š

image-20250209173822187

ä¹‹åä¼šåœ¨è¿™å‡ ä¸ªBBoxä¸­åˆ†åˆ«è¿›è¡Œè®¡ç®—cost schemeï¼Œå¾—åˆ°ä¸Šå›¾é»‘è‰²å®çº¿

fine-grained maze routing within guides

Postprocessing / Guide Patching  

we can add new guides to improve detailed routability. adding new stand-alone guides to alleviate routing hot spots.  

three kind of patching:

Pin Region Patching  

most effective  

the ideal way of improving pin accessibility is to identify those hard-to-access pins and assign more resources to them  

image-20250209191227014

Our global router will check the upper (or lower) two layers of a pin, which are vital for accessing the pin. use 3 Ã— 3 patching guides. 

æ²¡å†™åˆ¤æ–­hard-to-access pins  çš„å…·ä½“çš„æ–¹æ³•

Long Segment Patching:  

a longer routing segment often means more wrong way wires and causing more congestion.  

If a guide is longer than a specified length I, weâ€™ll consider long segment patching.  

image-20250209191725644

if a G-cell with resource below a threshold T is encountered, a single G-cell route guide will be patched above or below it, depending on which of them has sufficient resource  

Violation Patching:  

For G-cell with inevitable violations, patching will be used again to enable the detailed router to search with more flexibility.   

image-20250209192310471

data

iccad 2019 dataset

experiment

image-20241122113716242

image-20250209192916035

ä»–è‡ªå·±åˆæ¯”èµ›åæ”¹è¿›äº†

image-20250209195431218

our algorithmâ€™s peak memory is close to the first place and is 1.83 times of that of the second place on average (ours is 8.22 GB on average and is 19.8 GB for

the biggest design)

FastGR-GPU pattern routing+ multi thread mazeâ€“DATE-2022-PKU+CUHK+HNAL
GPU-accelerated

accelerated the 3D pattern routing algorithm of CUGR for initial routing by both net-level and path-level parallelization on GPU  

Gamer- -Trans-2022- -
GPU-accelerated

accelerated the two-level maze routing of CUGR for rip-up and reroute by updating vertical and horizontal routing costs alternatively on GPU  

GGR-super fast gpu accelerate-ICCAD-2022-
open sourceï¼Xplace/cpp_to_py/gpugr at main Â· cuhk-eda/Xplace

background

image-20241114223402627

Performance depends on the detail route

Modern global routing problem, which was introduced at the 2019 CAD contest at ICCAD, targets at closing
the gap between global routing and detailed routing. The LEF/DEF files for detailed routing are directly used as the input for global routing.  

The global routing quality is evaluated using an academic detailed router Dr. CU[8]  

2019 ICCAD contest on global routing did not directly evaluate global routing results based on overflows and total wirelength. The  new evaluation uses the global routing results as route guides for a detailed router, and the metrics are all detailed routing related  

2D & 3D

NCTU-GR 2.0[13], SPRoute[7] and FastRoute 4.0[14]  are 2D GR

However, compressed 2D grid graphs are less accurate than 3D grid graphs in terms of routing resources, which could limit the global routing quality.  

CUGR[11]. It has both 3D pattern routing and 3D maze  routing

multi-thread vs GPU

image-20241114225533925

image-20241114231041875

LEF/DEF based academic global routers  SPRoute 2.0[6] is the only 2D GR

GAMER[10] is a novel parallel maze routing algorithm integrated in CUGR.  

FastGR[12] introduced GPU parallelization of L-shape pattern routing  

contribution

image-20241114225935669

flow

image-20241114230008749

data

model

CUGR 2.0-DAG-based-DAC-2023- -CUHK
open source! 

background

many of the aforementioned global routers is that most of them rely heavily on time-consuming path search algorithms like maze routing to resolve overflows. These approaches are not efficient enough even with parallilization and may cause lots of unnecessary detours  

contribution:

a DAG-based generalized pattern routing algorithm

a new dynamic programming-based algorithm to calculate the routing cost

time complexity from $\mathcal{O}(L^4|V|)$ to $\mathcal{O}(L^2|V|)$

a DAG augmentation algorithm that enables the creation of alternative paths in a routing DAG.   can even shift or create Steiner points. over 99% nets can be successfully routed without the need of maze routing

a new sparse graph maze routing algorithm  

creation of alternative paths in a 

routing DAG

flow

RSMT 

image-20250210142956411

DFS andRouting DAG with L pattern

æ³¨æ„å¤šäº†èŠ‚ç‚¹g,f,i,h, ç°åœ¨æ¯æ¡éƒ½æ˜¯ç›´çº¿

image-20250210143037337

Routing DAG with other patternsï¼Œä½†æ˜¯åœ¨è¿™é‡Œæ²¡ç”¨åšåˆå§‹å¸ƒçº¿ï¼Œåˆå§‹åªç”¨äº†L-shapeã€‚æ–‡ç« ä¹Ÿå°±è¿™é‡Œæäº†ä¸€ä¸‹ï¼Œåé¢éƒ½å’Œè¿™ä¸ªæ— å…³ï¼Œå¾—å»æºç ä»”ç»†çœ‹çœ‹ã€‚

image-20250210143529434

Dynamic Programming-based DAG routing(L-shape + Layer assignment)

æ²¡è¯´æ€ä¹ˆèˆå¼ƒçš„ï¼Ÿ

DAG-based pattern routing with augmentation  

sparse graph maze routing algorithm

model

cost 

Dynamic Programming-based  

image-20250210203428984

DAG Augmentation for Congestion  

image-20250210203818643

create alternative paths   

image-20250210204123847

Steiner point movement

å…·ä½“æ€ä¹ˆç§»åŠ¨çš„æ–‡ç« ä¹Ÿæ²¡è¯´

experiment:

compare with CUGR [12] and SPRoute 2.0 [13]  

image-20250210211951988

image-20250210212311337

only one thread  for run time

image-20250210212636193

Effectiveness of  steiner point augmentation  

image-20250210212920933

run time compare with GPU-accelerated GR

compare with FastGR [14] and GAMER [15]  

GPUçš„å¥½åä¹Ÿæœ‰å…³ç³»å§ã€‚æœ¬å®éªŒç”¨çš„RTX 3090  

slightly faster than FastGR for initial routing 

image-20250210213728850

around 5.2Ã— as fast as GAMER

image-20250210215926150

InstantGR-Scalable GPU Parallelization-ICCAD-2024-CUHK
open source! 

second place of ISPD25 contest

GPU Parallelization  

parallel algorithm is mainly based on the DAG-based global routing algorithm in CUGR2.  åº”è¯¥æ˜¯3D pattern routing DPçš„éƒ¨åˆ†å’Œmaze routingçš„éƒ¨åˆ†

parallel while do initial routing  and RRR

æé«˜äº†å¹¶è¡Œåº¦ï¼Œä½†æ˜¯è¿˜æ˜¯æœ‰ä¸²è¡Œçš„éƒ¨åˆ†

ä¹Ÿç”¨äº†FLUTE

ä¸€å®šè¦ä»¥netä¸ºå•å…ƒå—ï¼Ÿæ˜¯ä¸ºäº†ç”¨DP

background

GPU memory is limited  

This requires memory-efficient solutions that can minimize CPU-GPU communication while maximizing GPU utilization  

large designs have more nets with bigger routing graphs, providing many new parallelization opportunities that are not yet explored  

nets in a batch can be routed in parallel

task:

parallelism for large-scale

partitioned  design

contribution

a new method for net-level batch generation. based on 3D fine-grained overlap checking and explores more parallelism by increasing the number of nets per batch

node-level parallel routing approach. achieves much higher parallelism compared to traditional net-level parallel routing.

flow

In initial routing, we construct a basic routing DAG to perform L-shape pattern routing.  

key points

specific explanation show in routing2

NET-LEVEL PARALLELISM  

simultaneous routing of a batch of nets that do not â€œoverlapâ€  

[2, 3, 14, 19, 20, 22, 26]  19å¹´å¼€å§‹çš„ï¼Œcugr2å’Œfastgréƒ½ç”¨äº†

Typical Batch Generation Algorithm  

used in [2, 3, 14, 19, 20]  

image-20250212100127751

R-trees æ˜¯å®ç°line 4çš„å¸¸ç”¨åšæ³•

pessimistically approximates  significantly lowers the degree of parallelism  

define and graph model

image-20250212111440550

image-20250212100930831

ä»¥segmentä¸ºå•ä½ï¼ŒåŒæ—¶åˆ†å¼€äº†æ°´å¹³å’Œå‚ç›´ä¸¤ä¸ªéƒ¨åˆ†ï¼Œå‡è®¾å…¨éƒ¨ä¸ºL-shapeï¼ŒåŒæ—¶å¯¹äºä¸åœ¨ä¸€æ¡çº¿ä¸Šçš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œæœ‰ä¸¤ä¸ªL

These four nets will be divided into just one batch based on our exact representation of routing graphs for overlap checking, while into four batches by the traditional bounding box-based pessimistic approximation  

via model:

image-20250212110626674

image-20250212104214378

viaç”¨ä¸€ä¸ªåå­—è¡¨ç¤º

Overlap Checking Algorithms  

ä»¥æ°´å¹³å­å›¾è¿›è¡Œå±•ç¤ºï¼Œå‚ç›´åŒç†

ä»¥æ°´å¹³segmentä¸ºå•ä½è¿›è¡Œchecking

é¦–å…ˆåˆ¤æ–­æ˜¯ä¸æ˜¯yåæ ‡ç›¸ç­‰ï¼šgroup the segments with the same ğ‘¦  

tradictional algorithm:

This is a classical computational geometry problem that can be efficiently solved by segment trees [1] in ğ‘‚(logğ‘›) time for both operations,   

image-20250212114550426

new algorithm motivation:

image-20250212114611742

segments are very short

new algorithm: Point Exhaustion

simply use a Boolean array to record whether each point in [1, ğ‘›] is covered by some segment ğ‘  âˆˆ ğ‘†. We mark every point ğ‘¥ âˆˆ [ğ‘™, ğ‘Ÿ] when a segment [ğ‘™, ğ‘Ÿ] is inserted, and check every point ğ‘¥ âˆˆ [ğ‘™ğ‘, ğ‘Ÿğ‘] for overlap query of a segment [ğ‘™ğ‘, ğ‘Ÿğ‘].   

further improve the efficiency of this point exhaustion by using bit arrays  

another improvement: representative point exhaustion  

allowing a little bit of overlap.   

it only checks the two end points of a query segment. ??ä»€ä¹ˆæ„æ€  

covering most overlap scenarios in practice.   

The only scenario that this algorithm fails to find the overlap of two overlapping segments is when the query segment [ğ‘™ğ‘,ğ‘Ÿğ‘] contains the overlapping segment [ğ‘™,ğ‘Ÿ], [ğ‘™,ğ‘Ÿ] âŠ‚ [ğ‘™ğ‘,ğ‘Ÿğ‘]  

NODE-LEVEL PARALLELISM

image-20250212142040816

è¿˜æ˜¯ä»¥netä¸ºå•ä½åˆ†åˆ°ä¸åŒçš„batchï¼Ÿ

routing nodes of the same depth in parallel  

image-20250212143816082

Suppose we have 4 nets, Net A, B, C and D in our grid graph. Since nets with overlap cannot be routed together, Net A and B are distributed to batch 0, as shown in Figure 7a, and nets C and D are distributed to batch 1.  

image-20250212143140834

experiment:

4 NVIDIA A800 GPUs and 8 CPU threads.

compare different overlap checking methods  

image-20250212145328644

The number of nets per batch is limited to 1000  

compare 2 largest benchmark

image-20250212154458440

compare with Top-3 Global Routers of ISPD2024 Contest   

image-20250212161238221

Runtime (s) of DAG-Based Augmented Routing with and without Node-Level Parallelism  

image-20250212161314333

acceleration é‚£ä¸€è¡Œå¥½åƒæ˜¯åŠ é€Ÿå€ç‡æ‰å¯¹

HeLEM-GR-Heterogeneous+Linearized Exponential Multiplier Method-ICCAD-2024- -PEK
first place of ISPD25 contest

not open source 2025/2/6

2D routing algorithm  

background

PRNet- -NeurIPS-2022- -SJTU+Noahâ€™s Ark
PRNet can generate each route in one-shot but cannot guarantee connectivity which requires considerablepost-processing for failed routes 

HubRouter æ˜¯ä¸¤é˜¶æ®µæ¡†æ¶ï¼ŒPRNet æ˜¯ç«¯åˆ°ç«¯æ¡†æ¶ã€‚ 

HubRouter-generative model-NeurIPS-2023-GAN+RL-SJTU
open source!

a chinese interpretation

a global routing solver that includes a two-phase learning framework

HubRouter æ˜¯ä¸¤é˜¶æ®µæ¡†æ¶ï¼ŒPRNet æ˜¯ç«¯åˆ°ç«¯æ¡†æ¶ã€‚

å¯¹æ¯” PRNet ç”Ÿæˆæ¨¡å‹ï¼ŒPRNet åœ¨ CGAN ä¸­ä½¿ç”¨åŒå‘æ˜ å°„å°†è¿æ¥çº¦æŸæ³¨å…¥è®­ç»ƒç›®æ ‡ï¼Œå°†å‡†ç¡®ç‡æé«˜äº† 10%ï¼Œä½†åœ¨å¤æ‚æƒ…å†µä¸‹å‡ ä¹æ— æ•ˆã€‚

background

image-20250210234157942

å…¨å±€å¸ƒçº¿(Global Routing - GR)æ˜¯ VLSI è®¾è®¡ä¸­æœ€å¤æ‚ä¸”æœ€è€—æ—¶çš„ç»„åˆé—®é¢˜ä¹‹ä¸€ã€‚GR ç›®æ ‡æ˜¯æ€»çº¿é•¿æœ€å°ï¼ŒåŒæ—¶é¿å…æ‹¥å¡(Congestion)ï¼Œæ˜¯ä¸ª NP é—®é¢˜ã€‚

ä¼ ç»Ÿé‡‡ç”¨å¯å‘å¼ç®—æ³•ï¼Œå¤šæ ·æ€§å’Œè§„æ¨¡é—®é¢˜å¯¹ä¼ ç»Ÿç®—æ³•æœ‰äº†æŒ‘æˆ˜ï¼Œæœºå™¨å­¦ä¹ (ML)å·²ç»ç”¨äºå…¨å±€å¸ƒçº¿ï¼Œåœ¨èŠ¯ç‰‡è®¾è®¡ä¸­ä»é€»è¾‘åˆæˆåˆ°å¸ƒå±€

æ·±åº¦å¼ºåŒ–å­¦ä¹ (Deep Reinforcement Learning - DRL )å’Œç”Ÿæˆå¼æ¨¡å‹(Generative model)å·²ç»è¢«ç”¨æ¥è§£å†³å…¨å±€å¸ƒçº¿ã€‚é—®é¢˜åœ¨äºï¼ŒDRLå¾ˆå—çŠ¶æ€ç©ºé—´(State Space)å½±å“ï¼Œéšç€ç½‘æ ¼ç©ºé—´å¢å¤§ï¼Œéœ€è¦èŠ±è´¹å¤§é‡æ—¶é—´ç”Ÿæˆã€‚However, DRL methods suffer from large state space and often need to spend enormous time on generating routes as the scale of grids increases on the test instance, i.e., the netlist, which is practically intimidating for real-world global routing  

ç›¸åï¼Œç”Ÿæˆå¼æ¨¡å‹æœ‰ä¸€æ¬¡æ€§ç”Ÿæˆèƒ½åŠ›ï¼Œåœ¨è®¡ç®—ä¸Šæ›´å®¹æ˜“å¤„ç†ã€‚

ç”Ÿæˆå¼æ–¹æ³•åœ¨è®­ç»ƒæ—¶å€™è€ƒè™‘è¿é€šæ€§é™åˆ¶ï¼Œç¡®ä¿å¸ƒçº¿æ»¡è¶³ç”µè·¯è¿é€šæ€§è¦æ±‚ã€‚ä½†æ˜¯é—®é¢˜åœ¨äºï¼Œå¦‚æœåˆå§‹ç”Ÿæˆè·¯å¾„ä¸æ»¡è¶³è¿é€šæ€§è¦æ±‚æ—¶å€™ï¼Œåå¤„ç†é˜¶æ®µä¼šå˜æˆä¸€ç§ç©·ä¸¾æœç´¢è¿‡ç¨‹ã€‚

image-20250210231714841

å›¾ä¸€è¿™é‡Œä¸Šå›¾è¡¨ç¤ºåŸå§‹å¸ƒçº¿ï¼Œä¸‹å›¾è¡¨ç¤ºç®—æ³•ç”Ÿæˆçš„å¸ƒçº¿ï¼Œç”Ÿæˆå¸ƒçº¿æ²¡æœ‰æ­£ç¡®è¿æ¥æ‰€æœ‰åº”è¯¥è¿æ¥çš„ç‚¹(pin)ï¼Œå¯¹äºè¿™æ ·çš„æƒ…å†µï¼Œå¹³å‡è¿é€šç‡å¾ˆä½ï¼Œä½äº20%ï¼Œæ„å‘³ç€è¶…è¿‡80%çš„ç”Ÿæˆå¸ƒçº¿éœ€è¦ç»è¿‡è€—æ—¶çš„åå¤„ç†æ‰èƒ½è¾¾åˆ°è¦æ±‚ã€‚æ˜¾è‘—çš„ç¼ºç‚¹ã€‚å…¶å®å°±å’ŒCNN-basedè¿™ç¯‡ä¸€æ ·

image-20250210233812834

contribution:

ä¸ºäº†è§£å†³ä¸Šè¿°é—®é¢˜ï¼Œå®šä¹‰äº†ä¸€ä¸ªæ–°çš„æ¦‚å¿µï¼Œå«hubã€‚å°†pin - piné—®é¢˜ --> hub - piné—®é¢˜ ã€‚

æå‡ºäº†ä¸€ç§æ–°çš„ä¸¤é˜¶æ®µå…¨å±€å¸ƒçº¿æ–¹æ³• --> HubRouter

generation phaseï¼ˆç”Ÿæˆé˜¶æ®µï¼‰

hubs, routes, and stripe masks are together generated under a multi-task framework by generative models  

å¯ä»¥åœ¨å¤šä¸ªæ¡†æ¶ä¸‹ç”Ÿæˆï¼Œæ¯”å¦‚ GAN (Generative Adversarial Nets) , VAE (Variational Auto-Encoder) , DPM (Diffusion Probabilistic Models) ã€‚è™½ç„¶hubæ˜¯ç”Ÿæˆé˜¶æ®µçš„ä¸»è¦è¾“å‡ºï¼Œä½†ä¸ºäº†æå‡ç”Ÿæˆè´¨é‡å’Œå‡†ç¡®æ€§ï¼Œå‘ç°ç”Ÿæˆé™„åŠ ä¿¡æ¯æ˜¯éå¸¸æœ‰ç”¨çš„ã€‚æ¯”å¦‚æ„ŸçŸ¥å’Œæ©ç (local perception and stripe masks)ï¼Œèƒ½å¤Ÿå»é™¤å™ªå£°ç‚¹ã€‚å¼•å…¥å¤šä»»åŠ¡å­¦ä¹ ï¼Œå¸ƒçº¿å’Œæ©ç ä¸€èµ·ç”Ÿæˆï¼Œæé«˜ hub ç”Ÿæˆè´¨é‡

pin-hub-connection phaseï¼ˆhubå’Œpinè¿æ¥é˜¶æ®µï¼‰

å°†è¿æ¥è§†ä¸ºæœ€å°æ–¯å¦çº³æ ‘(RSMT)é—®é¢˜ï¼Œä½¿ç”¨ actor-critic æ¨¡å‹ç½‘ç»œç­–ç•¥ã€‚

is hub generate correcttly, reconstruction time complexity can be reduced to O(n log n)  

SOTA generative global routing models  

model:

image-20250210234537382

Hub

image-20250212194312475

(virtual) key point in the route  

transferring the pin-pin connection problem to the hub-pin connection problem

æ–¯å¦çº³ç‚¹(Rectilinear Steiner Point --> RSP)æ˜¯æœç´¢å…¨å±€æœ€å°æ€»è·ç¦»ï¼Œä½†æ˜¯ hub æ˜¯æ¥ç¡®å®šè·¯å¾„ã€‚RSPs are special cases of hubs  

RSPæ˜¯Hubçš„ç‰¹ä¾‹ï¼ŒHubå¯ä»¥éšæ„ç”Ÿæˆä¸åŒå½¢çŠ¶çš„è·¯å¾„(ä¸ä»…æ˜¯æœ€çŸ­çš„)

è¿™é‡Œçš„ c å’Œ x åˆ†åˆ«ä»£è¡¨æ¡ä»¶å›¾åƒå’Œè¾“å…¥å›¾åƒã€‚æ¡ä»¶å›¾åƒå¯èƒ½åŒ…æ‹¬å¼•è„šä½ç½®ã€å·²ç»æå–çš„ä¸­å¿ƒç‚¹ä»¥åŠæ¡å¸¦æ©æ¨¡ï¼ˆstripe maskï¼‰ã€‚æ¡å¸¦æ©æ¨¡æ˜¯ç”¨æ¥æŒ‡ç¤ºå¸ƒçº¿åŒºåŸŸçš„ä¸€ç§æ–¹å¼ï¼Œå®ƒå¯ä»¥å¸®åŠ©æ¨¡å‹æ›´å¥½åœ°ç†è§£å“ªäº›åŒºåŸŸå¯ä»¥ç”¨äºå¸ƒçº¿

flow

image-20250212201906601

hubç”Ÿæˆé˜¶æ®µ

Hub ç”Ÿæˆå¯ä»¥è¡¨ç¤ºä¸ºå›¾åƒåˆ°å›¾åƒçš„multi-task learning framework   ä»»åŠ¡, address the impact of sensitive noise points with stripe mask learning  

é™„å½• B ä»‹ç»äº†å°† GANï¼ŒVAEï¼ŒEAN çº³å…¥åˆ°ç”Ÿæˆæ¡†æ¶

åœ¨è¿™ä¸ªé˜¶æ®µï¼Œæ¨¡å‹æ—¨åœ¨é€¼è¿‘æ¡ä»¶åˆ†å¸ƒ pÎ¸(x|z, c) ä½¿å…¶æ¥è¿‘å…ˆéªŒåˆ†å¸ƒ p(x|c)ã€‚ç»™å®šæ¡ä»¶ c å’Œä»å…ˆéªŒåˆ†å¸ƒ pz(z) ä¸­é‡‡æ ·å¾—åˆ°çš„æ½œåœ¨å˜é‡ zï¼ˆé€šå¸¸å‡è®¾ä¸ºé«˜æ–¯åˆ†å¸ƒï¼‰ï¼Œæ¨¡å‹ä¼šç”Ÿæˆä¸€äº›â€œä¸­å¿ƒç‚¹ï¼ˆhubsï¼‰â€. è¿™é‡Œçš„ c å’Œ x åˆ†åˆ«ä»£è¡¨æ¡ä»¶å›¾åƒå’Œè¾“å…¥å›¾åƒã€‚z is a latent variable from a prior distribution   

The main objective of hub generation is to minimize the difference between probability distributions  p(x|c) and pÎ¸(x|z, c)

a noise hub, especially the outermost one, can largely harm the wirelength of routing. Use stripe mask to focus on bad cases for hub generation  

image-20250212202848907

hubå’Œpinè¿æ¥é˜¶æ®µ

æ¨¡å‹è¿æ¥ç¬¬ä¸€é˜¶æ®µç”Ÿæˆçš„ä¸­å¿ƒç‚¹ï¼Œä»¥è·å¾—æœ€ç»ˆçš„å¸ƒçº¿è·¯ç”±ã€‚è¿™ä¸ªè¿‡ç¨‹å¯ä»¥è¢«è§†ä¸ºæ„å»ºçŸ©å½¢ç¨³å®šæœ€å°ç”Ÿæˆæ ‘ï¼ˆRectilinear Steiner Minimum Treeï¼ŒRSMTï¼‰çš„ä¸€éƒ¨åˆ†ã€‚ä¸ºäº†å®Œæˆå¸ƒçº¿ï¼Œæ¨¡å‹éµå¾ªäº†ä¸€ä¸ªåŸºäºå¼ºåŒ–å­¦ä¹ ï¼ˆReinforcement Learningï¼ŒRLï¼‰çš„ç®—æ³• RESTã€‚

åœ¨ä¸¤é˜¶æ®µçš„è¿‡ç¨‹ä¸­ï¼Œä½œè€…è¿˜æå‡ºäº†ä¸€ä¸ªå¤šä»»åŠ¡å­¦ä¹ æ¡†æ¶æ¥æé«˜ç”Ÿæˆä¸­å¿ƒç‚¹çš„è´¨é‡ã€‚ç‰¹åˆ«æ˜¯ï¼Œæå‡ºäº†ä¸€ç§æ–°é¢–çš„æ¡å¸¦æ©æ¨¡å­¦ä¹ æ–¹æ³•ï¼Œæ—¨åœ¨å‡è½»å™ªå£°ç‚¹æ¡ˆä¾‹å¯èƒ½é€ æˆçš„è´Ÿé¢å½±å“ã€‚ç®—æ³•çš„å…·ä½“ç»†èŠ‚åœ¨é™„å½• B ä¸­ç»™å‡ºã€‚

detail router
DRCU

academic detailed  

ç»¼è¿°
ML4PR
Towards Machine Learning for Placement and Routing in Chip Design: a Methodological Overview

image-20241101173512416

æ”¾ç½®å’Œå¸ƒçº¿æ˜¯ä¸¤ä¸ªä¸å¯æˆ–ç¼ºä¸”å…·æœ‰æŒ‘æˆ˜æ€§çš„ NP-hard é—®é¢˜

æœºå™¨å­¦ä¹ å‡­å€Ÿå…¶æ•°æ®é©±åŠ¨çš„æ€§è´¨æ˜¾ç¤ºå‡ºäº†å¹¿é˜”çš„å‰æ™¯ï¼Œå®ƒå¯ä»¥å‡å°‘å¯¹çŸ¥è¯†å’Œå…ˆéªŒçš„ä¾èµ–ï¼Œå¹¶ä¸”é€šè¿‡å…¶å…ˆè¿›çš„è®¡ç®—èŒƒå¼å…·æœ‰æ›´å¤§çš„å¯æ‰©å±•æ€§ (ä¾‹å¦‚ GPU åŠ é€Ÿçš„æ·±åº¦ç½‘ç»œ)

æŒ‘æˆ˜:

placement:

åœ¨è·¯ç”±å®Œæˆä¹‹å‰ï¼Œæ— æ³•è¯„ä¼°è¯¸å¦‚å¯è¾¾æ€§ä¹‹ç±»çš„æ”¾ç½®ç›®æ ‡ï¼›å› æ­¤ï¼Œåœ¨ä¼˜åŒ–å¾ªç¯ä¸­å¯èƒ½éœ€è¦èŠ±è´¹æ•°å°æ—¶æ‰èƒ½è·å¾—åé¦ˆï¼Œè¿™å¯¹äºè¿›è¡Œæ•°åƒæ¬¡æŸ¥è¯¢æ¥è¯´æ˜¯è´Ÿæ‹…ä¸èµ·çš„

ç°ä»£çš„æ”¾ç½®å™¨éœ€è¦åœ¨å‡ ä¸ªå°æ—¶å†…å¤„ç†æ•°ä¸‡ä¸ªå®å’Œæ•°ç™¾ä¸‡ä¸ªæ ‡å‡†å•å…ƒã€‚è¿™ç§å¯æ‰©å±•æ€§çš„è¦æ±‚ä»ç„¶è¶…å‡ºäº†ç°æœ‰ ML æ–¹æ³•çš„èƒ½åŠ›

routing:

åœ¨å…¬å¹³çš„æ¯”è¾ƒä¸‹ï¼Œç°æœ‰æŠ€æœ¯å¾ˆéš¾åœ¨æ•ˆç‡å’Œæ±‚è§£è´¨é‡ä¸Šç³»ç»Ÿåœ°ä¼˜äºç»å…¸å¸ƒçº¿ç®—æ³•

å¤§å¤šæ•°åŸºäºå­¦ä¹ çš„æŠ€æœ¯åœ¨å…·æœ‰æ•°åƒä¸ªç½‘ç»œçš„å°å‹ç”µè·¯ä¸Šå·¥ä½œå¾—å¾ˆå¥½ï¼Œè€Œå®é™…çš„å¸ƒçº¿å¼•æ“éœ€è¦åœ¨è¶…å¤§å‹ 3D ç½‘æ ¼å›¾ ( > 1000 Ã— 1000 Ã— 10 ) (> 1000 Ã— 1000 Ã— 10)(>1000Ã—1000Ã—10) ä¸Šæœ‰æ•ˆåœ°å¤„ç†æ•°ç™¾ä¸‡ä¸ªç½‘ç»œå¹¶äº§ç”Ÿé«˜è´¨é‡çš„è§£å†³æ–¹æ¡ˆ

ç›¸å…³å·¥ä½œ

placement

image-20241101175552665

image-20241101175600184

image-20241101175612168

Routing

image-20241101175915691

image-20241101175922593

image-20241101175934137

image-20241101180007732

image-20241101180029509

è¶…å¤§è§„æ¨¡é›†æˆç”µè·¯å¸ƒçº¿ç®—æ³•ç»¼è¿°  
è¶…å¤§è§„æ¨¡é›†æˆç”µè·¯å¸ƒçº¿ç®—æ³•ç»¼è¿°

background

image-20241116095906162

image-20241116095924293

image-20241116095932126

å¸ƒçº¿ç›¸å…³è¯¦ç»†çœ‹routing2.md, è¯¦ç»†å¸ƒçº¿ã€é¢å‘å¯åˆ¶é€ æ€§è®¾è®¡çš„å¸ƒçº¿ç®—æ³• è¿˜æ²¡è®°å½•

EDA+GNN
è¯¦ç»†çœ‹A Comprehensive Survey on Electronic Design Automation and Graph Neural Networks

å‚è€ƒ
AIæŠ€æœ¯å¸¦ç»™EDAçš„æœºé‡å’ŒæŒ‘æˆ˜

Towards Machine Learning for Placement and Routing in Chip Design: a Methodological Overview

ã€é˜…è¯»ã€‘A Comprehensive Survey on Electronic Design Automation and Graph Neural Networksâ€”â€”EDA+GNNç»¼è¿°ç¿»è¯‘_ppaml-CSDNåšå®¢

bak
CongestionNet-Congestion Prediction-IFIP-2019-GNN

-placement Congestion prediction-arXiv-2021-GNN

image-20241101171055570

è¾“å…¥ï¼šç½‘è¡¨

è¾“å‡ºï¼šcongestion at placement stage

EDA-ML: Graph Representation LearningFramework for Digital IC Design Automation

å¾·é›·å¡å°”å¤§å­¦ç”µæ°”ä¸è®¡ç®—æœºå·¥ç¨‹ç³» Pratik Shresthaå’ŒIoannis Savidis

background

VLSI : traditional methodologies -> ML,Graph representation learning  ability to capture complex relationships in graph-structured data  

GNNï¼š

image-20241116142013379

image-20241116142052562

task

image-20241116143449696

flow

image-20241116144708326

data

image-20241116155309167

image-20241116143927933

image-20241116155354597

æ¨¡å‹

image-20241116155947525

image-20241116155857412

å®éªŒ

image-20241116160529100

ç›¸å…³æ•°æ®é›†
only rtl
Home :: OpenCores
image-20241116140649477

IWLS 2005 Benchmarks
image-20241116140821429

image-20241116140834409

openlane-examples: Examples from the Openlane repository
image-20241118160109426

Global route
ISPD-2007
image-20250209155834613

the first published multilayer global routing benchmarks and the sizes of these benchmarks are large enough as compared to real industry cases  

has a two-layer and a six-layer version.  

ISPD-2008 
ICCAD-2019
2019 CAD Contest @ ICCAD

image-20241116171011534

image-20241116170739017

image-20241116170857585

image-20241116171107825

ISPD-2024
Dockerfileæ— æ³•åˆ›å»ºé•œåƒäº†ï¼Œ401ï¼ŒGithubä¹Ÿæ‰¾ä¸åˆ°benchmarks

image-20241116211927308

ISPD-2025
Detail Route
ISPD-2018/2019
Initial Detailed Routing Contest at ISPD 2018

Initial Detailed Routing Contest at ISPD 2019

ä¸€ä¸ªåˆ«äººå†™çš„parseè„šæœ¬ï¼šHandling-the-ISPD19-benchmark-dataset

https://ispd.cc/contests/19/ispd19eval.tgzï¼šä¸€ä¸ªç»“æœéªŒè¯å·¥å…·

image-20241116172911319

image-20241116173011828

è¿˜å¯ä»¥çœ‹çœ‹è¢«äººçš„ç»“æœ

image-20241116173156258

congestion/DRC/IR drop/timing
circuitnet/CircuitNet: CircuitNet: An Open-Source Dataset for Machine Learning Applications in Electronic Design Automation (EDA)

èƒŒæ™¯ï¼š

f.daixianiu.cn/csdn/14209355328255857.htmlåœ¨ç ”ç©¶è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å‘ç°AI+EDAçš„ç ”ç©¶å¸¸å¸¸å—é™äºå…¬å¼€æ•°æ®é›†ï¼Œä¸åƒè®¡ç®—æœºè§†è§‰é¢†åŸŸæœ‰ImageNetè¿™æ ·çš„å¤§æ•°æ®é›†å¯ä»¥å¾ˆæ–¹ä¾¿åœ°éªŒè¯ç®—æ³•ã€‚é’ˆå¯¹è¿™ä¸€é—®é¢˜ï¼Œæˆ‘ä»¬è¿‘æœŸè·Ÿé»„å¦‚é™¢å£«ã€ç‹æ¶¦å£°æ•™æˆç­‰åˆä½œï¼Œå‘å¸ƒäº†é¦–ä¸ªè‡´åŠ›äºèŠ¯ç‰‡è®¾è®¡AI for EDAåº”ç”¨çš„å¼€æºæ•°æ®é›†â€”â€”CircuitNetï¼ŒåŒ…å«1ä¸‡ä»¥ä¸Šçš„æ•°æ®æ ·æœ¬ï¼Œæ¶µç›–ä»å®é™…åˆ¶é€ å·¥è‰ºPDKä¸‹æ•°å­—è®¾è®¡æµç¨‹ä¸åŒé˜¶æ®µä¸­æå–åˆ°çš„å„ç±»ç‰¹å¾ã€‚

image-20241119154735598

image-20241116141127587

TimingPredict/TimingPredict: Official open source repository for "A Timing Engine Inspired Graph Neural Network Model for Pre-Routing Slack Prediction" (DAC 2022)

image-20241116141000835

ç›¸å…³ä¼šè®®/æœŸåˆŠ
ä¼šè®®
DAC:

æ¯å¹´ä¸¾åŠä¸€æ¬¡å­¦æœ¯è®ºå›å’Œå·¥ä¸šè´¸æ˜“å±•è§ˆ

ä¸€èˆ¬11æœˆæˆªæ­¢

ICCADï¼š

ç”±ç”µæ°”ç”µå­å·¥ç¨‹å¸ˆå­¦ä¼šï¼ˆIEEEï¼‰å’Œç¾å›½è®¡ç®—æœºå­¦ä¼šï¼ˆACMï¼‰å…±åŒä¸¾åŠçš„å›½é™…è®¡ç®—æœºè¾…åŠ©è®¾è®¡ä¼šè®®ï¼ˆICCADï¼‰è¢«å…¬è®¤ä¸ºEDAé¢†åŸŸæœ€é‡è¦çš„ä¼šè®®ä¹‹ä¸€ï¼Œäº«æœ‰å¾ˆé«˜çš„å›½é™…å­¦æœ¯åœ°ä½å’Œå¹¿æ³›çš„å½±å“åŠ›ã€‚è¯¥ä¼šè®®æ˜¯æ¢ç´¢EDAç ”ç©¶é¢†åŸŸæ–°æŒ‘æˆ˜ã€å±•ç¤ºå‰æ²¿åˆ›æ–°è§£å†³æ–¹æ¡ˆå’Œè¯†åˆ«æ–°å…´æŠ€æœ¯çš„é‡è¦è®ºå›ï¼Œæ¶µç›–äº†ä»å™¨ä»¶å’Œç”µè·¯çº§åˆ°ç³»ç»Ÿçº§çš„æ‰€æœ‰è®¾è®¡ä¸è‡ªåŠ¨åŒ–ä¸»é¢˜ã€ä»¥åŠåCMOSè®¾è®¡ç­‰æ–°å‹æ–¹å‘ã€‚ç€é‡äºå­¦æœ¯ç ”ç©¶ï¼Œè®ºæ–‡æ¶‰åŠä¸“é—¨çš„ç®—æ³•çš„ç ”ç©¶è¿›å±•ã€‚

ä¸€èˆ¬4æœˆæˆªæ­¢

DATE 2025

æ¬§æ´²è®¾è®¡è‡ªåŠ¨åŒ–å’Œæµ‹è¯•ä¼šè®®

ä¸€èˆ¬9æœˆæˆªæ­¢

ASP-DAC

äºšæ´²ã€å—å¤ªå¹³æ´‹è®¾è®¡è‡ªåŠ¨åŒ–ä¼šè®®

ä¸€èˆ¬7æœˆæˆªæ­¢

ISPDï¼š

å›½é™…ç‰©ç†è®¾è®¡ä¼šè®®ã€‚æ˜¯ä¸“æ³¨é›†æˆç”µè·¯ç‰©ç†è®¾è®¡çš„å›½é™…ç ”è®¨ä¼šï¼Œä¸»é¢˜æ¶µç›–ä»ASICå’ŒFPGAçš„ä¼ ç»Ÿç‰©ç†è®¾è®¡åˆ°æ–°å…´åŠå¯¼ä½“æŠ€æœ¯çš„ç‰©ç†è®¾è®¡è‡ªåŠ¨åŒ–æ–¹æ³•ã€‚

CCF-C. 9æœˆä»½å·¦å³

æ¯å¹´ISPDä¼šè®®åŒæ­¥ä¸¾åŠå›½é™…ç‰©ç†è®¾è®¡ç«èµ›ï¼Œé€šå¸¸ç”±å›½é™…çŸ¥åèŠ¯ç‰‡ä¼ä¸šå‘½é¢˜å’Œç»„ç»‡ï¼Œç«èµ›å†æ—¶3ä¸ªå¤šæœˆï¼Œç»“æœåœ¨ISPDä¼šè®®ä¸Šæ­æ™“ã€‚

GLSVLSI

CCF-C

å¤§æ¹–åŒºè¶…å¤§è§„æ¨¡é›†æˆç”µè·¯è®¾è®¡å›½é™…ä¼šè®®

ä¸€èˆ¬2æœˆæˆªæ­¢

25å¹´ä¸ºç¬¬35å±Š

image-20250209205712219

VLSI:

æœ‰ä¸ªDTCO?

ä¸€èˆ¬1æœˆ

image-20250209213619851

ISEDA:

ç”±IEEEå’ŒACMä¸»åŠï¼ŒEDAÂ²å’ŒCIE EDAå§”å‘˜ä¼šè”åˆä¸»åŠçš„ISEDA ï¼ˆEDAå›½é™…ç ”è®¨ä¼šï¼‰æ˜¯ä¸€ä¸ªè‡´åŠ›äºVLSIè®¾è®¡è‡ªåŠ¨åŒ–çš„å¹´åº¦é¡¶çº§è®ºå›ã€‚ç ”è®¨ä¼šæ—¨åœ¨æ¢ç´¢æ–°çš„æŒ‘æˆ˜ï¼Œå±•ç¤ºå‰æ²¿æŠ€æœ¯ï¼Œå¹¶ä¸ºEDAç¤¾åŒºæä¾›é¢„æµ‹EDAç ”ç©¶é¢†åŸŸæœªæ¥å‘å±•æ–¹å‘çš„æœºä¼šã€‚ISEDAæ¶µç›–äº†ä»å™¨ä»¶å’Œç”µè·¯çº§åˆ°ç³»ç»Ÿçº§çš„æ‰€æœ‰EDAä¸»é¢˜ï¼Œä»æ¨¡æ‹Ÿåˆ°æ•°å­—è®¾è®¡ä»¥åŠåˆ¶é€ ã€‚ä¼šè®®çš„å½¢å¼æ—¨åœ¨åŸ¹å…»å¯Œæœ‰æˆæ•ˆå’Œæ–°é¢–

äºŒæœˆ

25å¹´ç¬¬ä¸‰å±Š

image-20241210024033587

image-20241210023830404

æœŸåˆŠ
TCAD

ç”±ç¾å›½ç”µå™¨ç”µå­å·¥ç¨‹å¸ˆå­¦ä¼šï¼ˆIEEEï¼‰å‡ºç‰ˆ(å°±æ˜¯Trans?)

TODAES

ç”±ç¾å›½è®¡ç®—æœºå­¦ä¼šï¼ˆACMï¼‰å‡ºç‰ˆçš„ç”µå­ç³»ç»Ÿè®¾è®¡è‡ªåŠ¨åŒ–æ±‡åˆŠ

It publishes innovative work documenting significant research and development advances on the specification, design, analysis, simulation, testing, and evaluation of electronic systems, emphasizing a computer science/engineering orientation. Design automation for machine learning/AI and machine learning/AI for design automation are very much welcomed. For topics of interest please see https://dl.acm.org/journal/todaes/about.

ç›¸å…³ç§‘ç ”å®éªŒå®¤
æ¸…å
æ¸…åå¤§å­¦æ˜¯å›½å†…è¾ƒæ—©ä»äº‹EDAç ”ç©¶çš„é«˜æ ¡ï¼Œæ´ªå…ˆé¾™æ•™æˆå’Œè¾¹è®¡å¹´æ•™æˆåšç‰©ç†å®ç°å’Œé€»è¾‘ç»¼åˆï¼Œä¸¤ä½è€å…ˆç”Ÿçš„å­¦ç”Ÿå¤§éƒ¨åˆ†å»äº†ä¸‰å¤§EDAå…¬å¸

åŒ—å¤§-æ— é”¡EDAç ”ç©¶é™¢
æ— é”¡åŒ—äº¬å¤§å­¦ç”µå­è®¾è®¡è‡ªåŠ¨åŒ–ç ”ç©¶é™¢

åŒ—äº¬å¤§å­¦æ— é”¡ç”µå­è®¾è®¡è‡ªåŠ¨åŒ–ç ”ç©¶é™¢-å¼€æºå·¥å…·æ•´åˆ

image-20250105135331192

åŒ—äº¬å¤§å­¦é›†æˆç”µè·¯å­¦é™¢æˆç«‹äº†å›½å†…å”¯ä¸€èšç„¦EDAæŠ€æœ¯çš„â€œè®¾è®¡è‡ªåŠ¨åŒ–ä¸è®¡ç®—ç³»ç»Ÿç³»â€ï¼Œæ‰“é€ å…ˆè¿›çš„æ•™å­¦ä¸äººæ‰åŸ¹å…»ä½“ç³»ï¼Œå¹¶ä¸å›½å†…å¤–é¢†å…ˆçš„ä¼ä¸šæ·±å…¥åˆä½œï¼Œéƒ¨åˆ†æˆæœå·²ç»æˆåŠŸå¾—åˆ°è½¬åŒ–åº”ç”¨ï¼Œç›¸å…³æŠ€æœ¯æ˜¯ä¸šå†…ç›®å‰å”¯ä¸€çš„è§£å†³æ–¹æ¡ˆï¼›è¿‘æœŸä¾æ‰˜é™¢ç³»æ–°æˆç«‹äº†æ— é”¡åŒ—äº¬å¤§å­¦EDAç ”ç©¶é™¢ï¼ŒåŠ ä¸Šæ­¤å‰ä¸EDAåŠè®¾è®¡æ–¹å‘å¤´éƒ¨ä¼ä¸šå…±å»ºçš„å¤šä¸ªè”åˆå®éªŒå®¤ï¼Œå½¢æˆäº†æ•™è‚²ã€ç§‘æŠ€å’Œäººæ‰ä¸‰ä½ä¸€ä½“çš„å¸ƒå±€ã€‚

ç ”ç©¶æ–¹å‘åŒ…æ‹¬å¸ƒå±€å¸ƒçº¿ã€FPGAè®¾è®¡è‡ªåŠ¨åŒ–çš„å¯é‡æ„ç®—æ³•

æ—äº¦æ³¢Yibo Lin:yibolin@pku.edu.cn

Contest@ISPD 2024ç¬¬ä¸€åæŒ‡å¯¼çš„æœ¬ç§‘ç”Ÿèµµæ˜¥æºæå‡ºçš„é«˜æ•ˆGPUå¼‚æ„å¹¶è¡Œå¸ƒçº¿ç®—æ³•

CADathlon@ICCAD 2024ç¬¬ä¸€åæŒ‡å¯¼éƒ­èµ„æ”¿ï¼ˆæ¯•è®¾å¼€æºé¡¹ç›®ä½œè€…ï¼‰ã€éº¦æ™¯ã€‚åœ¨9å°æ—¶å†…ï¼Œè¿ç”¨è‡ªå·±çš„ç¼–ç å’Œåˆ†ææŠ€å·§æ¥è§£å†³6é“é›†æˆç”µè·¯ä¸ç³»ç»Ÿä¸­ç”µå­è®¾è®¡è‡ªåŠ¨åŒ–é—®é¢˜

CAD Contest@ICCADç¬¬ä¸€åæŒ‡å¯¼æœå®‡å‡¡ã€éƒ­èµ„æ”¿ã€‚Cèµ›é¢˜ã€ŠScalable Logic Gate Sizing Using ML Techniques and GPU Accelerationã€‹

DreamPlace, Limboå¼€æºé¡¹ç›®ä½œè€…

ç›¸å…³é‡‡è®¿åŒ—å¤§æ—äº¦æ³¢ï¼šæ¢ç´¢AI+EDAæ–°è·¯å¾„ | é’æºä¸“æ  2022-09

image-20250105141555651

ä¸€ä¸ªç°è±¡ï¼š

image-20250207165145656

ec7d7183c0dd379cccae82cd8354620

å¤æ—¦
é›†æˆèŠ¯ç‰‡ä¸ç³»ç»Ÿå›½å®¶é‡ç‚¹å®éªŒå®¤

ç ”ç©¶æ–¹å‘åŒ…æ‹¬ç‰©ç†å®ç°ã€å‚æ•°æå–ã€é€»è¾‘ç»¼åˆã€å¯åˆ¶é€ æ€§è®¾è®¡ç­‰æ–¹å‘

é™ˆå»ºåˆ©æ•™æˆ

æŒ‡å¯¼è”¡å¿—æ°ã€é­æ°‘ã€é‚¹é¹ï¼ŒISPD 2024 contest ç¬¬ä¸‰å

åŒ—èˆª
image-20241116114923595

æ¸¯ä¸­æ–‡-EDA Center
CUHK EDA Centerå®˜ç½‘

CUHK EDA Github

Bei Yu(ä½™å¤‡)@CUHK-CSE

byu@cse.cuhk.edu.hk

Research Topics

CAD Contest@ICCAD 2012ç¬¬äºŒåè·å¾—è€…

Siting Liu(åˆ˜æ€å©·)@CUHK-CSE

lusicaliu@outlook.com

F.Y. Young

image-20250209204835789

Jinwei Liu  

é™ˆå»·æ¬¢CHEN, Tinghuan

æ–¹å‘ï¼šVLSI CAD and deep learning accelerators for edge devices

chentinghuan@cuhk.edu.cn

CHEN, Tinghuan
ç¦å¤§
ç¦å·å¤§å­¦æ—©æœŸEDAç ”ç©¶å§‹äºèŒƒæ›´åæ•™æˆå’Œæœ±æ–‡å…´æ•™æˆï¼Œå½“å‰çš„ç ”ç©¶æ–¹å‘ä¸»è¦æ˜¯ç‰©ç†å®ç°ã€‚ç¦å·å¤§å­¦å›¢é˜Ÿæ›¾è¿ç»­ä¸‰å¹´åœ¨CAD Contest@ICCADå¤ºå† ã€‚

ç¦å·å¤§å­¦å›¢é˜Ÿåœ¨CAD Contest@ICCADå¤§èµ›ä¸­æå‡ºçš„6T&6T PPNNå•å…ƒå¸ƒå±€æ–¹æ³•å·²è½¬è®©ç»™åå¤§ä¹å¤©

æ—æ™ºé”‹æ•™æˆ

æŒ‡å¯¼é™ˆå¿†é¹­ã€å´æ˜­æ€¡ï¼Œ ISPD 2024 contest ç¬¬ä¸‰å

ä¸Šæµ·äº¤å¤§
é¦–é¡µ_ä¸Šæµ·äººå·¥æ™ºèƒ½å®éªŒå®¤

ä¸œå—å¤§å­¦-å›½å®¶ASICå·¥ç¨‹ä¸­å¿ƒ
ç ”ç©¶æ–¹å‘æ˜¯äºšé˜ˆå€¼å’Œè¿‘é˜ˆå€¼ç›¸å…³çš„æ—¶åºåˆ†æ

CAD Contest@ICCAD 2017ç¬¬ä¸€åè·å¥–è€…ç¦å·å¤§å­¦çš„æœ±è‡ªç„¶ï¼ˆZiran Zhuï¼‰æ¯•ä¸šåä»»æ•™äºä¸œå—å¤§å­¦ASICä¸­å¿ƒ

2020å¹´å’Œå›½å¾®é›†å›¢æˆç«‹EDAè”åˆå®éªŒå®¤ï¼Œç„å‡†EDAå…±æ€§æŠ€æœ¯ç ”å‘

æ—¶é¾™å…´:

è€æ‰€é•¿

é—«æµ©:

yanhao@seu.edu.cn

é¢†åŸŸï¼šæ™ºèƒ½EDAï¼Œé¢å‘å…ˆè¿›å·¥è‰ºã€é«˜èƒ½æ•ˆç”µè·¯è®¾è®¡ä¸­å­˜åœ¨çš„é—®é¢˜ï¼Œåº”ç”¨äººå·¥æ™ºèƒ½ç®—æ³•è¾…åŠ©ç”µè·¯è®¾è®¡ï¼›å…ˆè¿›åˆ¶ç¨‹/ä½ç”µå‹ä¸‹çš„æ—¶åºåˆ†æä¸ä¼˜åŒ–

åä¸­ç§‘æŠ€å¤§å­¦
è¥¿å®‰ç”µå­ç§‘æŠ€å¤§å­¦
åœ¨å›½å†…è¾ƒæ—©å¼€å§‹ä»äº‹æˆå“ç‡åˆ†æç®—æ³•çš„ç ”ç©¶ï¼Œå¹¶ä¸”ä¸€ç›´åœ¨å®½ç¦å¸¦åŠå¯¼ä½“çš„å™¨ä»¶å»ºæ¨¡ã€å¯é æ€§åˆ†æç­‰é¢†åŸŸæœ‰æ·±å…¥çš„ç ”ç©¶å’Œçªå‡ºçš„æˆæœ

åœ¨2019å¹´å’Œå›¯å¾®é›†å›¢å»ºç«‹EDAç ”ç©¶é™¢ä¹‹åï¼Œå¼€å§‹è¿›å…¥å¸ƒå±€å¸ƒçº¿å’ŒåŸå‹éªŒè¯é¢†åŸŸ

å¹¿ä¸œå·¥ä¸šå¤§å­¦
ç”µå­è®¾è®¡è‡ªåŠ¨åŒ–ï¼ˆEDAï¼‰ç§‘ç ”å›¢é˜Ÿ-å¹¿ä¸œå·¥ä¸šå¤§å­¦é›†æˆç”µè·¯å­¦é™¢

ç”µå­è®¾è®¡è‡ªåŠ¨åŒ–ï¼ˆEDAï¼‰ç§‘ç ”å›¢é˜Ÿä¾æ‰˜å¹¿ä¸œå·¥ä¸šå¤§å­¦é›†æˆç”µè·¯å­¦é™¢æˆç«‹ã€‚é¢å‘äººå·¥æ™ºèƒ½è¾…åŠ©é›†æˆç”µè·¯è®¾è®¡EDAå·¥å…·å¼€å‘ã€åº”ç”¨ç­‰å›½å®¶é‡å¤§æˆ˜ç•¥ä¸è¡Œä¸šé‡å¤§éœ€æ±‚ï¼Œä»¥äººå·¥æ™ºèƒ½è¾…åŠ©EDAä¸ºç ”ç©¶æ ¸å¿ƒï¼Œèšç„¦äºæ•°å­—é›†æˆç”µè·¯è®¾è®¡åç«¯å·¥å…·ã€FPGAè®¾è®¡å·¥å…·ä¼˜åŒ–ç­‰é¢†åŸŸçš„å‰æ²¿åŸºç¡€ç†è®ºå’Œå…³é”®æŠ€æœ¯ç ”ç©¶ã€‚å›¢é˜Ÿä¸»è¦å¼€å±•â€œæ•°æ®é©±åŠ¨æœºå™¨å­¦ä¹ çš„é›†æˆç”µè·¯æ™ºèƒ½è®¾è®¡â€ã€â€œäººå·¥æ™ºèƒ½æ–¹æ³•å®ç°é›†æˆç”µè·¯çš„æ•æ·è®¾è®¡â€ã€â€œåŸºäºä¼ ç»Ÿçš„åˆ†æå’Œä¼˜åŒ–æŠ€æœ¯çš„é›†æˆç”µè·¯è¾…åŠ©è®¾è®¡â€ç­‰ç ”ç©¶

image-20241214171155300

æ•°æ®é©±åŠ¨æœºå™¨å­¦ä¹ çš„é›†æˆç”µè·¯æ™ºèƒ½è®¾è®¡

äººå·¥æ™ºèƒ½æ–¹æ³•å®ç°é›†æˆç”µè·¯çš„æ•æ·è®¾è®¡

åŸºäºä¼ ç»Ÿçš„åˆ†æå’Œä¼˜åŒ–æŠ€æœ¯çš„é›†æˆç”µè·¯è¾…åŠ©è®¾è®¡

image-20241214171245832

å›½ç«‹æ¸…åå¤§å­¦
University of California  
Design Automation Laboratory

ç›¸å…³ä¼ä¸š/æœºæ„
åä¸ºè¯ºäºšæ–¹èˆŸ & æµ·æ€
Huawei Noahâ€™s Ark Lab AI4EDA

CAD Contest@ICCAD 2018ç¬¬ä¸€åè·å¥–è€…é¦™æ¸¯ä¸­æ–‡å¤§å­¦çš„é™ˆåŠ²æ¾ï¼ˆJingsong Chenï¼Œ2021å¹´åšå£«æ¯•ä¸šï¼‰æ¯•ä¸šååŠ å…¥åä¸º

EDAå›½åˆ›ä¸­å¿ƒ
ä¸ä¸œå—å¤§å­¦æœ‰å…³è”

ä¸­å¿ƒä»‹ç»â€”å›½å®¶é›†æˆç”µè·¯è®¾è®¡è‡ªåŠ¨åŒ–æŠ€æœ¯åˆ›æ–°ä¸­å¿ƒï¼ŒEDAå›½åˆ›ä¸­å¿ƒã€å®˜æ–¹ç½‘ç«™ã€‘

image-20241211184948328

image-20241214171422358

èŠ¯è¡Œçºª
image-20241214160736661

AmazeSys
åº”ç”¨äºæ•°å­—èŠ¯ç‰‡ç‰©ç†è®¾è®¡é¢†åŸŸçš„å¸ƒå±€å¸ƒçº¿å·¥å…·

åŒ…å«å®å•å…ƒå¸ƒå±€è§„åˆ’ã€ç”µæºè§„åˆ’ã€å¸ƒå±€ã€æ—¶é’Ÿæ ‘ç»¼åˆã€å¸ƒçº¿ã€ä¼˜åŒ–ã€å¯„ç”Ÿå‚æ•°æå–ä»¥åŠæ—¶åºåŠŸè€—åˆ†æç­‰å…¨åŠŸèƒ½æ¨¡å—ï¼Œæ”¯æŒå…ˆè¿›å·¥è‰ºåˆ¶ç¨‹ä¸‹çš„è¶…å¤§è§„æ¨¡è®¾è®¡ï¼Œå¯å®Œæˆæ•°å­—èŠ¯ç‰‡ä»Netliståˆ°GDSçš„å®Œæ•´è®¾è®¡æµç¨‹ï¼Œå¿«é€Ÿè¾¾æˆæ€§èƒ½ã€åŠŸè€—ã€é¢ç§¯ä¼˜åŒ–ç­‰è®¾è®¡ç›®æ ‡

åŸºäºå¼ºå¤§çš„æœºå™¨å­¦ä¹ å¼•æ“å†…æ ¸ï¼ŒAmazeSyså…·å¤‡è‡ªé€‚åº”è¶…é«˜è´¨é‡ä¼˜åŒ–èƒ½åŠ›ã€‚è¯¥å¼•æ“æ™ºèƒ½æå–è®¾è®¡æœ¬èº«ç‰¹ç‚¹è¿›è¡Œæ ·æœ¬è®­ç»ƒï¼Œç»¼åˆæ€§èƒ½ã€åŠŸè€—ã€é¢ç§¯å’Œå¸ƒçº¿æ‹¥å¡ç­‰å¤šé¡¹å…³é”®æŒ‡æ ‡ï¼Œå¿«é€Ÿè·å–é‡èº«å®šåˆ¶çš„æœ€ä½³ä¼˜åŒ–æ–¹æ¡ˆï¼Œå¯æœ‰æ•ˆå¸®åŠ©ç”¨æˆ·é™ä½è°ƒæ•´å¤§é‡å·¥å…·è®¾ç½®çš„æ—¶é—´æˆæœ¬ã€‚

AmazeFP
æ™ºèƒ½å¸ƒå±€è§„åˆ’å·¥å…·AmazeFPå°†æœºå™¨å­¦ä¹ æŠ€æœ¯ä¸å¸ƒå±€è§„åˆ’å¼•è­¦ç»“åˆï¼Œåœ¨å…¼é¡¾æ€§èƒ½ã€åŠŸè€—å’Œé¢ç§¯(PPA)çš„åŒæ—¶ï¼Œæä¾›äº†é«˜åº¦æ™ºèƒ½çš„æ‹¥å¡æ„ŸçŸ¥ã€ä¾¿æ·çš„æ•°æ®æµåˆ†æå’Œå®å•å…ƒè‡ªåŠ¨æ•´ç†å¯¹é½åŠŸèƒ½ï¼Œæœ‰æ•ˆè§£å†³å½“å‰æ•°å­—èŠ¯ç‰‡åœ¨åç«¯è®¾è®¡é˜¶æ®µçš„å¸ƒå±€è§„åˆ’èŠ‚ç‚¹é¢ä¸´çš„ç»éªŒå€¼éœ€æ±‚é«˜ã€æ‰‹å·¥è€—æ—¶é•¿ã€æ•°æ®æµç»“æ„åˆ†æä¸å¤Ÿæ·±å…¥ã€è®¾è®¡ç›®æ ‡æ”¶æ•›æ€§å·®ç­‰éš¾é¢˜ï¼ŒåŠ©åŠ›ç”¨æˆ·åœ¨åç«¯è®¾è®¡åˆæœŸå¿«é€Ÿæœ‰æ•ˆåœ°è·å–é«˜è´¨é‡å¸ƒå±€è§„åˆ’æ–¹æ¡ˆï¼Œå‡å°‘è¿­ä»£æ¬¡æ•°ï¼Œä»è€ŒèŠ‚çº¦å¤§è§„æ¨¡è®¾è®¡çš„ç ”å‘æˆæœ¬ï¼Œæé€Ÿäº§å“ä¸Šå¸‚æ—¶é—´ã€‚

AmazeFP-ME
ä½œä¸ºä¸€æ¬¾EDAæœºå™¨å­¦ä¹ çš„å·¥å…·ï¼ŒAmazeFP-MEåœ¨AmazeFPçš„åŸºç¡€ä¸Šï¼Œèƒ½å¤Ÿå¿«é€Ÿæ¢ç´¢æ•°ç™¾å€ç”šè‡³æ›´å¤šçš„åºå¤§è§£ç©ºé—´ï¼Œæ— éœ€ç”¨æˆ·æ‰‹åŠ¨è°ƒå‚ï¼ŒåŒæ—¶é…å¤‡ä¼˜å¼‚ä¸”ç²¾å‡†çš„æ•°æ®ã€å›¾å½¢åˆ†æåŠŸèƒ½ï¼Œå¯ä¸ºç”¨æˆ·æä¾›é«˜æ•ˆä¾¿æ·çš„è®¾è®¡ä½“éªŒ

AmazeFP-MEä½œä¸ºAmazeFPçš„AIé…å¥—å·¥å…·ï¼Œå°†æœºå™¨å­¦ä¹ æŠ€æœ¯å¼•å…¥åˆ°AmazeFPçš„è§£ç©ºé—´æ¢ç´¢ä¸­ï¼Œä¸ä»…è¿›ä¸€æ­¥æ˜¾è‘—åœ°æå‡äº†PPAï¼Œè¿˜ä¸ºç”¨æˆ·åˆ›é€ å…¨æ–°çš„è‡ªåŠ¨åŒ–ä½¿ç”¨ä½“éªŒã€‚

AmazeDRCLite
image-20241214162304222

äº‘
åå¤§ä¹å¤©
ä¸œå—å¤§å­¦-åå¤§ä¹å¤©-NiiCEDAè”åˆå®éªŒå®¤

PyAether
Aetherå°±æ˜¯å…¨å®šåˆ¶ç”µè·¯ï¼ˆä¾‹å¦‚æ¨¡æ‹Ÿã€å­˜å‚¨ã€å°„é¢‘ã€å¹³æ¿ç­‰ï¼‰è®¾è®¡å¹³å°ï¼ŒåŒ…æ‹¬åŸç†å›¾ï¼Œç‰ˆå›¾ï¼Œä»¿çœŸç¯å¢ƒï¼Œä»¥åŠæ•°æ®ç‰ˆæœ¬ç®¡ç†å·¥å…·å’ŒPythonæ¥å£ç­‰ã€‚

Pythonæ‹¥æœ‰ä¼—å¤šé’ˆå¯¹**æ•°æ®ç§‘å­¦å’Œäººå·¥æ™ºèƒ½çš„å¼ºå¤§çš„å¼€æºåº“ï¼Œä¾‹å¦‚NumPyå’ŒPandasç”¨äºæ•°æ®å¤„ç†ï¼ŒMatplotlibç”¨äºæ•°æ®å¯è§†åŒ–ï¼ŒScikit-Learnæä¾›äº†å¤§é‡çš„é¢„å¤„ç†æ–¹æ³•å’Œæœºå™¨å­¦ä¹ ç®—æ³•ï¼ŒTensorFlowå’ŒPyTorchåˆ™æ˜¯æ·±åº¦å­¦ä¹ é¢†åŸŸçš„é‡è¦å·¥å…·ã€‚è¿™äº›åº“å¤§å¤§é™ä½äº†å¼€å‘éš¾åº¦ï¼Œä½¿å¾—Pythonåœ¨AIé¢†åŸŸçš„åœ°ä½æ— å¯æ›¿ä»£ã€‚æ‰€ä»¥æ— è®ºæ˜¯æ•°æ®æ¸…æ´—å’Œé¢„å¤„ç†ï¼Œè¿˜æ˜¯æ¨¡å‹å»ºç«‹ï¼Œä¾‹å¦‚å†³ç­–æ ‘ï¼Œç¥ç»ç½‘ç»œï¼Œè´å¶æ–¯ä¼˜åŒ–ç­‰ï¼Œä»¥åŠæ¨¡å‹è®­ç»ƒå’Œæµ‹è¯•ï¼Œå¯¹æ¨¡å‹ç»“æœçš„è§£è¯»ç­‰ï¼Œéƒ½ä¼šå¤©ç„¶çš„ä½¿ç”¨Python**ã€‚

æ‰€ä»¥Pythonçš„å¼€æ”¾æ€§ç”Ÿæ€ã€å¤©ç„¶çš„æ•°æ®æŒ–æ˜ã€åŒ…æ‹¬æœºå™¨å­¦ä¹ çš„äººå·¥æ™ºèƒ½ï¼ˆAIï¼‰ä»¥åŠå„ç±»ç®—æ³•ä¼˜åŒ–åŒ…ï¼Œå‹å¥½çš„webå¼€å‘ï¼Œä½¿ç”¨æˆ·å¯ä»¥åœ¨æ›´å¼€æ”¾ã€æ›´å¼ºå¤§çš„ç”Ÿæ€ä½“ç³»é‡Œå¼€å±•è®¾è®¡ã€‚å¯ä»¥ç”¨å®ƒæ¥æ„å»ºç”µè·¯ä¸ç‰ˆå›¾çš„è‡ªåŠ¨åŒ–ä»»åŠ¡ï¼Œå¿«é€Ÿè¿›è¡Œæ•°æ®å¤„ç†å’Œåˆ†æã€‚ä¾‹å¦‚ï¼ŒPyAetherå¯ä»¥èµ‹èƒ½IC CADï¼Œæ›´å¥½å¾—å“åº”IC è®¾è®¡å’Œç‰ˆå›¾å„ç§è¦æ±‚ã€‚

10æœˆ18æ—¥æ·±åº¦è§£æ PyAether EDA ç”Ÿæ€ç³»ç»Ÿï¼Œå¸¦æ‚¨æ¢ç´¢ç”µè·¯è®¾è®¡è‡ªåŠ¨åŒ–çš„ç§˜ç±ï¼ - åå¤§ä¹å¤©PyAether - EETOP åˆ›èŠ¯ç½‘è®ºå› (åŸåï¼šç”µå­é¡¶çº§å¼€å‘ç½‘) -

image-20250112113619108

image-20250113112132020

import pyAether


class InvLe:

    def __init__(self, lib, cell, tech_lib, view="layout", mode="a"):
        r"""InvLe init function, receive the specified layout information.

        Parameters
        ----------
        lib : str
            Library name.
        cell : str
            Cell name.
        tech_lib : str
            Attach tech library name.
        view : str
            View name, the default value is 'layout'.
        mode : str
            Mode for open design, the default value is 'a'.
        """
        pyAether.emyInitDb()
        pyAether.emyInitLog()
        self.pnt_x = 0
        self.pnt_y = 0
        self.namespace = pyAether.emyUnixNS()
        self.design = self.open_design(lib, cell, view, mode=mode)
        self.block = self.design.getTopBlock()
        if self.block is None:
            self.block = pyAether.emyBlock.create(self.design)
        self.uu2dbu = self.block.getDBUPerUU()
        oplib = self.design.getLib()
        tech_scl = pyAether.emyScalarName(self.namespace, tech_lib)
        tech = pyAether.emyTech.open(tech_scl)
        tech.attach(oplib, tech_scl)

    def open_design(self, lib, cell, view, view_type="maskLayout", mode="r"):
        r"""This function is used to open design and return an emyDesign object.

        Parameters
        ----------
        lib : str
            Library name.
        cell : str
            Cell name.
        view : str
            View name.
        view_type : str
            Type of view, the default value is 'layout'.
        mode : str
            Mode for open design, the default value is 'r'.

        Returns
        -------
        design : emyDesign
            An emyDesign object opened by given parameters.
        """
        lib_scl = pyAether.emyScalarName(self.namespace, lib)
        cell_scl = pyAether.emyScalarName(self.namespace, cell)
        view_scl = pyAether.emyScalarName(self.namespace, view)
        reserved_view = pyAether.emyReservedViewType(view_type)
        view_type = pyAether.emyViewType.get(reserved_view)
        design = pyAether.emyDesign.open(lib_scl, cell_scl, view_scl,
                                         view_type, mode)

        return design

    def create_inst(self, master_lib, master_cell, master_view, inst_name,
                    point, params, **kwargs):
        r"""This function creates an emyScalarInst object on specified block.

        Parameters
        ----------
        master_lib : str
            Library name of instance.
        master_cell : str
            Cell name of instance.
        master_view : str
            View name of instance.
        inst_name : str
            Text string of instance.
        point : tuple
            Point to create an emyTransform object, such as (0, 0).
        params: emyParamArray
            emyParamArray
        kwargs
            Other keyword arguments,
            here specifies view_type, mode, view, status.
        """
        view_type = kwargs.get("view_type", "maskLayout")
        mode = kwargs.get("mode", "r")
        view = kwargs.get("view", pyAether.emcInheritFromTopBlock)
        status = kwargs.get("status", pyAether.emcNonePlacementStatus)
        master = self.open_design(master_lib, master_cell, master_view,
                                  view_type, mode)
        inst_scl_name = pyAether.emyScalarName(self.namespace, inst_name)
        pnt_x0, pnt_y0 = point
        point_1 = pyAether.emyPoint(int(pnt_x0 * self.uu2dbu),
                                    int(pnt_y0 * self.uu2dbu))
        trans = pyAether.emyTransform(point_1)
        pyAether.emyScalarInst.create(self.block, master, inst_scl_name, trans,
                                      params, view, status)

    def create_net(self, net_name, path, **kwargs):
        r"""This function creates an emyScalarNet object on specified block.

        Parameters
        ----------
        net_name : str
            It specifies the net name string.
        path : list
            It specifies path list.
        kwargs
            Other keyword arguments,
            here specifies sigType, isGlobal, view.

        Returns
        -------
        scl_net : emyScalarNet
            An emyScalarNet object created by given parameters.
        """
        sig_type = kwargs.get("sigType",
                              pyAether.emySigType(pyAether.emcSignalSigType))
        is_global = kwargs.get("isGlobal", False)
        view = kwargs.get(
            "view",
            pyAether.emyBlockDomainVisibility(pyAether.emcInheritFromTopBlock))
        net = pyAether.emyScalarName(self.namespace, net_name)
        scl_net = pyAether.emyScalarNet.create(self.block, net, sig_type,
                                               is_global, view)
        path.addToNet(scl_net)

        return scl_net

    def create_path(self, layer, purpose, width, start_point, end_point):
        r"""This function creates an emyScalarNet object on specified block.

        Parameters
        ----------
        layer : str
            It specifies the layer name string.
        purpose : str
            It specifies the purpose name string.
        width : float
            Define the width of the path.
        start_point : tuple
            Path start point, such as (0, 0).
        end_point : tuple
            Path end point, such as (1, 1).

        Returns
        -------
        path : emyPath
            A path object created by given parameters.
        """
        (sta_x0, sta_y0), (end_x0, end_y0) = start_point, end_point
        sta_pnt = pyAether.emyPoint(
            int(self.pnt_x * self.uu2dbu) + int(sta_x0 * self.uu2dbu),
            int(self.pnt_y * self.uu2dbu) + int(sta_y0 * self.uu2dbu))
        end_pnt = pyAether.emyPoint(
            int(self.pnt_x * self.uu2dbu) + int(end_x0 * self.uu2dbu),
            int(self.pnt_y * self.uu2dbu) + int(end_y0 * self.uu2dbu))
        points = [sta_pnt, end_pnt]
        layernum = pyAether.emyGetLayerNumByName(self.design, layer)
        purposenum = pyAether.emyGetPurposeNumByName(self.design, purpose)
        wid = int(width * self.uu2dbu)
        path = pyAether.emyPath.create(self.block, layernum, purposenum, wid,
                                       points)
        return path

    def create_gr(self, centerLine, templateName, **kwargs):
        r"""This function creates an emyScalarNet object on specified block.

        Parameters
        ----------
        centerLine : emyPointArrayF
            Set the drawing route of the guard ring.
        templateName : str
            Set the template name of the guard ring.
        kwargs
            Other keyword arguments,
            here specifies type, justify, offset, topLayer, stackMode, maxContPattern,
            isBodyMode, bodyWidth, contRow, contSpaceX, contSpaceY, contSizeX, contSizeY,
            bIsChamfer, chamferAmount, metalSameBody, stackSameMetal, cornerContact.

        Returns
        -------
        rect_nwgr : emyRect
            Build nwGuardRings.
        """

        type = kwargs.get("type", "Polygon")
        justify = kwargs.get("justify", "Center")
        offset = kwargs.get("offset", 0)
        topLayer = kwargs.get("topLayer", None)
        stackMode = kwargs.get("stackMode", False)
        maxContPattern = kwargs.get("maxContPattern", False)
        isBodyMode = kwargs.get("isBodyMode", True)
        bodyWidth = kwargs.get("bodyWidth", 0.5)
        contRow = kwargs.get("contRow", 0)
        contSpaceX = kwargs.get("contSpaceX", 0)
        contSpaceY = kwargs.get("contSpaceY", 0)
        contSizeX = kwargs.get("contSizeX", 0)
        contSizeY = kwargs.get("contSizeY", 0)
        bIsChamfer = kwargs.get("bIsChamfer", False)
        chamferAmount = kwargs.get("chamferAmount ", 0)
        metalSameBody = kwargs.get("metalSameBody", False)
        stackSameMetal = kwargs.get("stackSameMetal", False)
        cornerContact = kwargs.get("cornerContact", True)

        pyAether.aeCrtGuardring(self.design,
                                centerLine,
                                templateName,
                                type=type,
                                justify=justify,
                                offset=offset,
                                stackMode=stackMode,
                                maxContPattern=maxContPattern,
                                isBodyMode=isBodyMode,
                                contRow=contRow,
                                contSpaceX=contSpaceX,
                                topLayer=topLayer,
                                contSpaceY=contSpaceY,
                                contSizeX=contSizeX,
                                contSizeY=contSizeY,
                                bIsChamfer=bIsChamfer,
                                chamferAmount=chamferAmount,
                                metalSameBody=metalSameBody,
                                stackSameMetal=stackSameMetal,
                                cornerContact=cornerContact,
                                bodyWidth=bodyWidth)

    def close(self):
        r"""This function save and close the emyDesign object which is opened.

        """
        self.design.save()
        self.design.close()

    def create(self, x_0, y_0):
        r"""This function creates an inverter.

        """
        self.pnt_x = x_0
        self.pnt_y = y_0
        # Create scalar instances
        params_p18 = pyAether.emyParamArray()
        params_p18.append(pyAether.emyParam('Single_Width', '1u'))

        self.create_inst("reference_pdk", "p18", "layout", "M0", (0.43, 3.15),
                         params_p18)

        # pyAether.emyArray()
        params_n18 = pyAether.emyParamArray()
        params_n18.append(pyAether.emyParam('Single_Width', '600n'))
        params_n18.append(pyAether.emyParam('SD_Metal_Width', '370n'))
        self.create_inst("reference_pdk", "n18", "layout", "M1", (0.29, 1.17),
                         params_n18)

        # Create path
        path1 = self.create_path("GT", "drawing", 0.18, (1.0, 3.15),
                                 (1.0, 1.77))
        path2 = self.create_path("M1", "drawing", 0.23, (1.36, 3.47),
                                 (1.36, 1.21))
        path3 = self.create_path("M1", "drawing", 0.23, (0.64, 1.21),
                                 (0.64, 0.18))
        path4 = self.create_path("M1", "drawing", 0.23, (0.64, 4.11),
                                 (0.64, 5.14))

        # Create net
        self.create_net("Y", path1)
        self.create_net("A", path2)
        self.create_net("vss", path3)
        self.create_net("vdd", path4)

        # create GR
        self.create_gr([(0.53, 4.89), (1.47, 4.89)], "NWGR", bodyWidth=0.4)

        # create PGR
        self.create_gr([(0.52, 0.41), (1.48, 0.41)], "PGR", bodyWidth=0.4)


if __name__ == '__main__':
    example = InvLe("lib01", "test", "reference_pdk", "layout", mode="w")
    example.create(0, 0)
    example.close()
æ¦‚ä¼¦ç”µå­
æ”¶è´­äº†Entasys

image-20241223162717895

é¸¿èŠ¯å¾®çº³
image-20250105132642028

image-20250105132734272

åèŠ¯å·¨æ•°
æµ™æ±Ÿ

image-20250105132135256

image-20250105132149726

å˜‰ç«‹åˆ›
PCB

ç›¸å…³ç«èµ›
CADathlon@ICCAD
CADathlon@ICCAD 2024 | ICCAD 2024

EDAé¢†åŸŸçš„â€œå¥¥æ—åŒ¹å…‹è¿åŠ¨ä¼šâ€ï¼Œå§‹äº2002å¹´

in-person event, all-day programming competition, 9 hours, two-person teams, information about the problems and relevant research papers will be released online one week before the competition. 

ä¸€èˆ¬åœ¨10æœˆä»½ä¸¾åŠ

six problems

Circuit Design & Analysis

Physical Design & Design for Manufacturability

Logic & High-Level Synthesis

System Design & Analysis

Functional Verification & Testing

Future technologies (Bio-EDA, Security, AI, etc.)

Contest@ISPD
International Symposium on Physical Design (ISPD)

äº2005å¹´é¦–æ¬¡ä¸¾åŠ

Contest@ISPDä½œä¸ºISPDç ”è®¨ä¼šçš„ä¸€éƒ¨åˆ†ï¼Œæ˜¯å…¨çƒä¸‰å¤§é¡¶å°–å›½é™…ç‰©ç†è®¾è®¡å­¦æœ¯ç«èµ›ä¹‹ä¸€ï¼Œç”±å…¨çƒç ”ç©¶è®¡ç®—æœºç§‘å­¦çš„æƒå¨å­¦ä¼šACMï¼ˆAssociation for Computing Machineryï¼‰æ‰€ä¸¾åŠ

æ¯å¹´12æœˆä»½ç”±ä¸šç•Œä¸€æµå…¬å¸ï¼ˆIBMã€Intelã€Xilinxç­‰ï¼‰å…¬å¸ƒå­¦æœ¯ç«èµ›é¢˜ç›®ï¼Œ3æœˆä»½æäº¤ç ”å‘æˆæœå’Œè½¯ä»¶ç³»ç»Ÿï¼Œç”±ä¸šç•Œå…¬å¸è´Ÿè´£æä¾›æµ‹è¯•ç”µè·¯ï¼Œå¹¶æµ‹è¯•å‚èµ›é˜Ÿä¼æ‰€æäº¤çš„è½¯ä»¶ç³»ç»Ÿï¼Œæœ€åäº3æœˆåº•æˆ–4æœˆåˆåœ¨å¹´åº¦ACM ISPDä¼šè®®ä¸Šå…¬å¸ƒç«èµ›ç»“æœã€‚

é¢˜ç›®	First Place
2015	Blockage-Aware Detailed Routing-Driven Placement Contest	NTUPlacerDR
CAD Contest@ICCAD
å§‹äº 2012å¹´

è¦†ç›–äº†EDAå‰ç«¯ï¼ˆfront-endï¼‰å’Œåç«¯ï¼ˆback-endï¼‰

ç”±IEEE CEDAã€ACM SIGDAå’Œå·¥ä¸šç•ŒCadenceã€Synopsysç­‰å…±åŒèµåŠ©

Each year the organizing committee announce three challenging problems in different topic, can participate in one or more problems

Blockage-Aware Detailed Routing-Driven Placement Contest

image-20241214172612304

å†å¹´ç›¸å…³èµ›é¢˜
é¢˜ç›®	Sponsor
2024-C	Scalable Logic Gate Sizing Using ML Techniques and GPU Acceleration	Nvidia
2011	Routability-driven Placement Contest and Benchmark Suite	
ä¾ å®¢å²›
EDAç²¾è‹±æŒ‘æˆ˜èµ›
TAU Contest
Tau 2021 Contest

æ•°å­—ç”µè·¯æ—¶åºåˆ†æç«èµ›ï¼ˆTAUï¼‰

å§‹äº2011å¹´ï¼Œæ˜¯ç”±å›½é™…è®¡ç®—æœºåä¼šACMæ‰€ä¸¾åŠçš„ä¸“ä¸šèµ›äº‹

ä¸€èˆ¬ç”±IBMã€Cadenceã€Synopsysã€TMSCç­‰å›½é™…é¡¶å°–å…¬å¸å‚ä¸å‘½é¢˜

å¥½åƒåˆ°21å¹´å°±æ²¡äº†ã€‚ã€‚ã€‚

Programming Contest@IWLS
IWLS Contest

å§‹äº2017å¹´

æ˜¯ç”±IEEE/ACM International Workshop on Logic & Synthesisï¼ˆIWLSï¼‰ä¸¾åŠ

ç”±ä¸šç•Œä¸€æµå…¬å¸ï¼ˆSynopsysã€Xilinxã€Googleç­‰ï¼‰å…¬å¸ƒç«èµ›é¢˜ç›®

ä»¥é€»è¾‘ç»¼åˆï¼ˆLogic Synthesisï¼‰å’Œå·¥å…·ç ”å‘ä¸ºç«èµ›ä¸»é¢˜

â€œå…¨å›½å¤§å­¦ç”Ÿé›†æˆç”µè·¯åˆ›æ–°åˆ›ä¸šå¤§èµ›â€çš„åå¤§ä¹å¤©èµ›é“
image-20241214193431391

å…¨å›½å¤§å­¦ç”Ÿé›†æˆç”µè·¯åˆ›æ–°åˆ›ä¸šå¤§èµ›

ç¬¬å…«å±Šé›†åˆ›èµ›æ¯èµ›é¢˜ç›®â€”â€”åå¤§ä¹å¤©æ¯ - å…¨å›½å¤§å­¦ç”Ÿé›†æˆç”µè·¯åˆ›æ–°åˆ›ä¸šå¤§èµ›

image-20241214203159713

image-20241214203523404

LLM4HWDesign Contest
2024å¹´ICCADæ–°è®¾ç«‹LLM for Hardware Design Contest

LLM4HW Designç«èµ›æ—¨åœ¨ä¸ºç¡¬ä»¶ä»£ç ç”Ÿæˆæ„å»ºå¤§è§„æ¨¡ã€é«˜è´¨é‡çš„Verilogä»£ç ç”Ÿæˆæ•°æ®é›†ã€‚åœ¨åŸºäºLLMçš„ç¡¬ä»¶ä»£ç ç”Ÿæˆä¸­å¼•å‘ä¸€åœºç±»ä¼¼ImageNetçš„é©å‘½ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç›®æ ‡ï¼ŒLLM4HWDesignç«èµ›é¼“åŠ±å‚ä¸è€…æ”¶é›†æ•°æ®æ ·æœ¬ï¼Œå¹¶å¼€å‘åˆ›æ–°çš„æ•°æ®æ¸…ç†å’Œæ ‡è®°æŠ€æœ¯ï¼Œä»¥æœ‰æ•ˆæé«˜ç¡¬ä»¶ä»£ç ç”Ÿæˆæ•°æ®é›†çš„è§„æ¨¡å’Œè´¨é‡ï¼Œä¸ºæ¨è¿›LLMè¾…åŠ©ç¡¬ä»¶è®¾è®¡å·¥ä½œæµç¨‹å»ºç«‹å…³é”®åŸºç¡€è®¾æ–½ã€‚

DAC System Design Contest 
DAC 2012 Routability-Driven Placement Contest and Benchmark Suite

image-20241220204933457

å‚è€ƒ
ç›˜ç‚¹å…¨çƒé¡¶çº§EDAç«èµ›åŠä¸­å›½å¤§é™†è·å¥–æƒ…å†µ|æ¸…åå¤§å­¦|ç¦å·å¤§å­¦|iccad|ä¸Šæµ·äº¤é€šå¤§å­¦|eda_ç½‘æ˜“è®¢é˜…

ç›¸å…³PDK
